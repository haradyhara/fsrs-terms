<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FSRSç”¨èªæš—è¨˜ã‚¢ãƒ—ãƒª - GitHubé€£æºç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 2rem;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #48bb78, #38a169);
        }

        .btn-danger {
            background: linear-gradient(45deg, #e53e3e, #c53030);
        }

        .btn-hard {
            background: linear-gradient(45deg, #ed8936, #dd6b20);
        }

        .btn-good {
            background: linear-gradient(45deg, #4299e1, #3182ce);
        }

        .btn-easy {
            background: linear-gradient(45deg, #48bb78, #38a169);
        }

        .btn-github {
            background: linear-gradient(45deg, #333, #24292e);
        }

        .file-input {
            display: none;
        }

        .file-label {
            padding: 12px 24px;
            background: linear-gradient(45deg, #ed8936, #dd6b20);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .main-content {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .upload-area {
            text-align: center;
            padding: 60px 20px;
            border: 2px dashed #cbd5e0;
            border-radius: 15px;
            background: #f7fafc;
        }

        .upload-area h2 {
            color: #4a5568;
            margin-bottom: 20px;
        }

        .github-setup {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
        }

        .github-setup h3 {
            color: #333;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .connection-status {
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-connected {
            background: #c6f6d5;
            color: #276749;
            border: 2px solid #9ae6b4;
        }

        .status-disconnected {
            background: #fed7d7;
            color: #c53030;
            border: 2px solid #fbb6ce;
        }

        .status-loading {
            background: #bee3f8;
            color: #2b6cb0;
            border: 2px solid #90cdf4;
        }

        .terms-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .term-card {
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .term-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            border-color: #667eea;
        }

        .term-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(45deg, #667eea, #764ba2);
        }

        .term-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 10px;
        }

        .term-stats {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .stat-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .miss-count {
            background: #fed7d7;
            color: #c53030;
        }

        .difficulty {
            background: #bee3f8;
            color: #2b6cb0;
        }

        .next-review {
            background: #c6f6d5;
            color: #276749;
        }

        .quiz-container {
            text-align: center;
            padding: 40px 20px;
        }

        .quiz-term {
            font-size: 2.5rem;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 20px;
            padding: 30px;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            border-radius: 15px;
            border: 2px solid #e2e8f0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quiz-term:hover {
            background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
            transform: scale(1.02);
        }

        .quiz-term.show-definition {
            background: linear-gradient(135deg, #e6fffa 0%, #b2f5ea 100%);
            border-color: #38b2ac;
        }

        .quiz-definition {
            font-size: 1.2rem;
            color: #4a5568;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px dashed #cbd5e0;
            display: none;
        }

        .quiz-definition.visible {
            display: block;
        }

        .quiz-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 30px;
        }

        .quiz-button {
            padding: 15px 25px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            min-width: 120px;
        }

        .quiz-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .detail-container {
            padding: 20px;
        }

        .detail-term {
            font-size: 2rem;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 20px;
            text-align: center;
        }

        .detail-description {
            font-size: 1.1rem;
            line-height: 1.6;
            color: #4a5568;
            background: #f7fafc;
            padding: 25px;
            border-radius: 12px;
            border-left: 4px solid #667eea;
            margin-bottom: 30px;
        }

        .back-button {
            display: block;
            margin: 0 auto;
        }

        .mode-indicator {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            display: inline-block;
        }

        .stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #4a5568;
        }

        .quiz-hint {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            padding: 10px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .debug-info {
            background: #f0f8ff;
            border: 1px solid #b0c4de;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 0.9rem;
            color: #483d8b;
        }

        .help-text {
            background: #fffacd;
            border: 1px solid #f0e68c;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-size: 0.9rem;
            color: #8b4513;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            max-width: 350px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background: linear-gradient(45deg, #48bb78, #38a169);
        }

        .notification.error {
            background: linear-gradient(45deg, #e53e3e, #c53030);
        }

        .notification.info {
            background: linear-gradient(45deg, #4299e1, #3182ce);
        }

        .offline-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: #ed8936;
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .data-backup-info {
            background: #f0f8ff;
            border: 2px solid #b0c4de;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-size: 0.9rem;
            color: #1e40af;
        }

        .quick-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .quick-stat {
            background: rgba(102, 126, 234, 0.1);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .quick-stat-number {
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
        }

        .quick-stat-label {
            font-size: 0.8rem;
            color: #4a5568;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }
            
            .quiz-term {
                font-size: 1.8rem;
            }
            
            .terms-grid {
                grid-template-columns: 1fr;
            }

            .quiz-buttons {
                flex-direction: column;
                align-items: center;
            }

            .stats {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ§  FSRSç”¨èªæš—è¨˜ã‚¢ãƒ—ãƒª - GitHubé€£æºç‰ˆ</h1>
            <div class="controls">
                <button id="githubSetupBtn" class="btn btn-github">ğŸ”§ GitHubè¨­å®š</button>
                <label for="yamlFile" class="file-label">
                    ğŸ“ YAMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
                </label>
                <input type="file" id="yamlFile" class="file-input" accept=".yaml,.yml">
                <button id="loadFromGitHubBtn" class="btn btn-secondary" disabled>ğŸ“¥ GitHubã‹ã‚‰èª­ã¿è¾¼ã¿</button>
                <button id="dictionaryMode" class="btn" disabled>ğŸ“š è¾æ›¸ãƒ¢ãƒ¼ãƒ‰</button>
                <button id="quizMode" class="btn" disabled>ğŸ§  ã‚¯ã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰</button>
                <button id="saveToGitHubBtn" class="btn btn-secondary" disabled>ğŸ’¾ GitHubã«ä¿å­˜</button>
                <button id="downloadBtn" class="btn btn-secondary" disabled>ğŸ’¾ YAMLãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
                <button id="helpBtn" class="btn" style="background: linear-gradient(45deg, #9f7aea, #805ad5);">â“ ãƒ˜ãƒ«ãƒ—</button>
            </div>
        </div>

        <div class="main-content">
            <!-- GitHubè¨­å®šç”»é¢ -->
            <div id="githubSetupScreen" style="display: none;">
                <div class="github-setup">
                    <h3>ğŸ”§ GitHubé€£æºè¨­å®š</h3>
                    
                    <div id="connectionStatus" class="connection-status status-disconnected">
                        âŒ GitHubæœªæ¥ç¶š
                    </div>

                    <div class="form-group">
                        <label for="githubToken">Personal Access Token:</label>
                        <input type="password" id="githubToken" placeholder="ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx">
                        <div class="help-text">
                            <strong>Personal Access Tokenã®ä½œæˆæ–¹æ³•:</strong><br>
                            1. GitHub â†’ Settings â†’ Developer settings â†’ Personal access tokens â†’ Tokens (classic)<br>
                            2. "Generate new token (classic)" ã‚’ã‚¯ãƒªãƒƒã‚¯<br>
                            3. Note: "FSRS Terms App"<br>
                            4. Expiration: ãŠå¥½ã¿ã®æœŸé–“<br>
                            5. Select scopes: "repo" ã«ãƒã‚§ãƒƒã‚¯<br>
                            6. "Generate token" ã‚’ã‚¯ãƒªãƒƒã‚¯<br>
                            7. ç”Ÿæˆã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã“ã“ã«è²¼ã‚Šä»˜ã‘
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="repoOwner">ãƒªãƒã‚¸ãƒˆãƒªã‚ªãƒ¼ãƒŠãƒ¼:</label>
                        <input type="text" id="repoOwner" placeholder="your-username">
                    </div>

                    <div class="form-group">
                        <label for="repoName">ãƒªãƒã‚¸ãƒˆãƒªå:</label>
                        <input type="text" id="repoName" placeholder="fsrs-terms">
                    </div>

                    <div class="form-group">
                        <label for="yamlPath">YAMLãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹:</label>
                        <input type="text" id="yamlPath" placeholder="data/terms.yaml" value="data/terms.yaml">
                    </div>

                    <div class="form-group">
                        <label for="mainBranch">ãƒ–ãƒ©ãƒ³ãƒå:</label>
                        <input type="text" id="mainBranch" placeholder="main" value="main">
                    </div>

                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button id="testConnectionBtn" class="btn btn-secondary">ğŸ”Œ æ¥ç¶šãƒ†ã‚¹ãƒˆ</button>
                        <button id="saveGitHubSettingsBtn" class="btn">ğŸ’¾ è¨­å®šä¿å­˜</button>
                        <button id="closeSetupBtn" class="btn btn-danger">âŒ é–‰ã˜ã‚‹</button>
                    </div>
                </div>
            </div>

            <!-- ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”»é¢ -->
            <div id="uploadScreen" class="upload-area">
                <h2>ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿æ–¹æ³•ã‚’é¸æŠã—ã¦ãã ã•ã„</h2>
                <p>YAMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã™ã‚‹ã‹ã€GitHubé€£æºã‚’è¨­å®šã—ã¦ã‚¯ãƒ©ã‚¦ãƒ‰ã‹ã‚‰èª­ã¿è¾¼ã‚ã¾ã™</p>
                <div style="margin-top: 20px;">
                    <button class="btn btn-github" onclick="document.getElementById('githubSetupBtn').click()">
                        ğŸ”§ GitHubé€£æºã‚’è¨­å®š
                    </button>
                </div>
                <small style="color: #718096; margin-top: 10px; display: block;">
                    â€» æ—§å½¢å¼ã®YAMLãƒ•ã‚¡ã‚¤ãƒ«ã¯è‡ªå‹•çš„ã«FSRSå½¢å¼ã«å¤‰æ›ã•ã‚Œã¾ã™
                </small>
            </div>

            <!-- è¾æ›¸ç”»é¢ -->
            <div id="dictionaryScreen" style="display: none;">
                <div class="mode-indicator">ğŸ“š è¾æ›¸ãƒ¢ãƒ¼ãƒ‰</div>
                
                <!-- ã‚¯ã‚¤ãƒƒã‚¯çµ±è¨ˆ -->
                <div class="quick-stats">
                    <div class="quick-stat">
                        <div class="quick-stat-number" id="totalTerms">0</div>
                        <div class="quick-stat-label">ç·ç”¨èªæ•°</div>
                    </div>
                    <div class="quick-stat">
                        <div class="quick-stat-number" id="dueTerms">0</div>
                        <div class="quick-stat-label">å¾©ç¿’å¯¾è±¡</div>
                    </div>
                    <div class="quick-stat">
                        <div class="quick-stat-number" id="totalReviews">0</div>
                        <div class="quick-stat-label">ç·å¾©ç¿’å›æ•°</div>
                    </div>
                    <div class="quick-stat">
                        <div class="quick-stat-number" id="avgDifficulty">0</div>
                        <div class="quick-stat-label">å¹³å‡é›£æ˜“åº¦</div>
                    </div>
                    <div class="quick-stat">
                        <div class="quick-stat-number" id="masteredTerms">0</div>
                        <div class="quick-stat-label">ç¿’å¾—æ¸ˆã¿</div>
                    </div>
                </div>

                <!-- å­¦ç¿’é€²æ—ãƒãƒ¼ -->
                <div style="margin: 20px 0;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <span style="font-weight: 600; color: #4a5568;">å…¨ä½“ã®å­¦ç¿’é€²æ—</span>
                        <span id="progressPercentage" style="font-size: 0.9rem; color: #667eea;">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                    </div>
                </div>

                <!-- ãƒ‡ãƒ¼ã‚¿ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æƒ…å ± -->
                <div id="backupInfo" class="data-backup-info" style="display: none;">
                    <strong>ğŸ“¡ ãƒ‡ãƒ¼ã‚¿åŒæœŸæƒ…å ±:</strong><br>
                    æœ€çµ‚åŒæœŸ: <span id="lastSyncTime">æœªåŒæœŸ</span><br>
                    æœªä¿å­˜ã®å¤‰æ›´: <span id="unsavedChanges">ãªã—</span>
                </div>

                <div id="termsGrid" class="terms-grid"></div>
            </div>

            <!-- ã‚¯ã‚¤ã‚ºç”»é¢ -->
            <div id="quizScreen" style="display: none;">
                <div class="mode-indicator">ğŸ§  ã‚¯ã‚¤ã‚ºãƒ¢ãƒ¼ãƒ‰ - FSRS v6</div>
                <div class="quiz-hint">ç”¨èªã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨å®šç¾©ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>
                <div class="quiz-container">
                    <div id="quizTerm" class="quiz-term">
                        <div id="termText"></div>
                        <div id="quizDefinition" class="quiz-definition"></div>
                    </div>
                    <div class="quiz-buttons">
                        <button id="againBtn" class="quiz-button btn-danger">âŒ Again</button>
                        <button id="hardBtn" class="quiz-button btn-hard">ğŸ”¶ Hard</button>
                        <button id="goodBtn" class="quiz-button btn-good">âœ… Good</button>
                        <button id="easyBtn" class="quiz-button btn-easy">âš¡ Easy</button>
                    </div>
                    <div id="debugInfo" class="debug-info" style="display: none;"></div>
                </div>
            </div>

            <!-- è©³ç´°ç”»é¢ -->
            <div id="detailScreen" style="display: none;">
                <div class="detail-container">
                    <div id="detailTerm" class="detail-term"></div>
                    <div id="detailDescription" class="detail-description"></div>
                    <div id="detailStats" class="stats" style="justify-content: flex-start;">
                        <div class="stat-item">
                            <div class="stat-number" id="detailDifficulty">0</div>
                            <div class="stat-label">é›£æ˜“åº¦</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="detailStability">0</div>
                            <div class="stat-label">å®‰å®šæ€§(æ—¥)</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="detailReviews">0</div>
                            <div class="stat-label">å¾©ç¿’å›æ•°</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="detailRetrievability">0</div>
                            <div class="stat-label">æƒ³èµ·ç¢ºç‡</div>
                        </div>
                    </div>
                    <button id="backBtn" class="btn back-button">ğŸ“š è¾æ›¸ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã‚‹</button>
                </div>
            </div>
        </div>
    </div>

    <!-- é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ  -->
    <div id="notification" class="notification"></div>

    <!-- ã‚ªãƒ•ãƒ©ã‚¤ãƒ³è¡¨ç¤º -->
    <div id="offlineIndicator" class="offline-indicator">
        ğŸ“¡ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ - å¤‰æ›´ã¯æ¬¡å›ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ™‚ã«åŒæœŸã•ã‚Œã¾ã™
    </div>

    <script>
        // FSRSçŠ¶æ…‹ã®å®šæ•°
        const State = {
            NEW: 0,
            LEARNING: 1,
            REVIEW: 2,
            RELEARNING: 3
        };

        // FSRSè©•ä¾¡ã®å®šæ•°
        const Rating = {
            AGAIN: 1,
            HARD: 2,
            GOOD: 3,
            EASY: 4
        };

        /**
         * FSRS (Free Spaced Repetition Scheduler) å®Ÿè£…
         */
        class FSRSCalculator {
            constructor(parameters = {}) {
                this.w = parameters.w || [
                    0.2172, 1.1771, 3.2602, 16.1507, 7.0114, 0.57, 2.0966, 0.0069, 1.5261, 0.112,
                    1.0178, 1.849, 0.1133, 0.3127, 2.2934, 0.2191, 3.0004, 0.7536, 0.3332, 0.1437, 0.2
                ];
                
                this.requestRetention = parameters.requestRetention || 0.9;
                this.maximumInterval = parameters.maximumInterval || 36500;
                this.easyBonus = parameters.easyBonus || 1.3;
                this.hardInterval = parameters.hardInterval || 1.2;
                
                this.FACTOR = 19 / 81;
                this.DECAY = -0.5;
                this.enableDebug = false;
                
                this.intervalCache = new Map();
                this.retrievabilityCache = new Map();
            }

            createEmptyCard(now = new Date()) {
                return {
                    due: now,
                    stability: 0,
                    difficulty: 0,
                    elapsed_days: 0,
                    scheduled_days: 0,
                    reps: 0,
                    lapses: 0,
                    state: State.NEW,
                    last_review: null
                };
            }

            calculateRetrievability(elapsed_days, stability) {
                if (stability <= 0) return 1.0;
                if (elapsed_days < 0) return 1.0;
                
                const cacheKey = `${elapsed_days.toFixed(2)}_${stability.toFixed(2)}`;
                if (this.retrievabilityCache.has(cacheKey)) {
                    return this.retrievabilityCache.get(cacheKey);
                }
                
                const factor = this.FACTOR * elapsed_days / stability;
                const result = Math.pow(1 + factor, this.DECAY);
                
                if (this.retrievabilityCache.size < 1000) {
                    this.retrievabilityCache.set(cacheKey, result);
                }
                
                return result;
            }

            calculateInitialStability(rating) {
                return Math.max(this.w[rating - 1], 0.1);
            }

            calculateInitialDifficulty(rating) {
                const difficulty = this.w[4] - (rating - 3) * this.w[5];
                return Math.max(Math.min(difficulty, 10), 1);
            }

            calculateNextStability(difficulty, stability, retrievability, rating) {
                const hard_penalty = rating === Rating.HARD ? this.w[15] : 1;
                const easy_bonus = rating === Rating.EASY ? this.w[16] : 1;
                
                const factor = Math.exp(this.w[8]) * 
                             (11 - difficulty) * 
                             Math.pow(stability, -this.w[9]) * 
                             (Math.exp(this.w[10] * (1 - retrievability)) - 1) + 1;
                
                return Math.max(stability * factor * hard_penalty * easy_bonus, 0.01);
            }

            calculateForgetStability(difficulty, stability, retrievability) {
                const newStability = this.w[11] * 
                                   Math.pow(difficulty, -this.w[12]) * 
                                   (Math.pow(stability + 1, this.w[13]) - 1) * 
                                   Math.exp(this.w[14] * (1 - retrievability));
                
                return Math.max(Math.min(newStability, stability), 0.01);
            }

            calculateNextDifficulty(difficulty, rating) {
                const delta = rating - 3;
                const nextDifficulty = difficulty - this.w[6] * delta;
                return Math.max(Math.min(nextDifficulty, 10), 1);
            }

            calculateInterval(stability, retention = null) {
                if (retention === null) retention = this.requestRetention;
                if (stability <= 0) return 1;
                
                const cacheKey = `${stability.toFixed(2)}_${retention.toFixed(2)}`;
                if (this.intervalCache.has(cacheKey)) {
                    return this.intervalCache.get(cacheKey);
                }
                
                try {
                    const interval = stability / this.FACTOR * 
                                   (Math.pow(retention, 1 / this.DECAY) - 1);
                    
                    const result = Math.max(interval, 1);
                    
                    if (this.intervalCache.size < 1000) {
                        this.intervalCache.set(cacheKey, result);
                    }
                    
                    return result;
                } catch (error) {
                    console.warn('é–“éš”è¨ˆç®—ã§ã‚¨ãƒ©ãƒ¼:', error);
                    return Math.max(stability, 1);
                }
            }

            reviewCard(card, rating, reviewTime = new Date()) {
                try {
                    if (!card || typeof card !== 'object') {
                        throw new Error('ç„¡åŠ¹ãªã‚«ãƒ¼ãƒ‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ');
                    }
                    
                    if (!reviewTime || !(reviewTime instanceof Date) || isNaN(reviewTime)) {
                        reviewTime = new Date();
                    }
                    
                    if (typeof card.state !== 'number' || card.state < 0 || card.state > 3) {
                        card.state = State.NEW;
                    }
                    
                    if (typeof card.stability !== 'number' || card.stability < 0) {
                        card.stability = 0;
                    }
                    
                    if (typeof card.difficulty !== 'number' || card.difficulty < 1 || card.difficulty > 10) {
                        card.difficulty = 5;
                    }
                    
                    const now = reviewTime.getTime();
                    const lastReview = card.last_review ? new Date(card.last_review).getTime() : now;
                    const elapsed_days = Math.max((now - lastReview) / (1000 * 60 * 60 * 24), 0);

                    let newCard = { ...card };
                    
                    if (card.state === State.NEW) {
                        newCard.stability = this.calculateInitialStability(rating);
                        newCard.difficulty = this.calculateInitialDifficulty(rating);
                        newCard.elapsed_days = 0;
                        
                        if (rating === Rating.AGAIN) {
                            newCard.state = State.LEARNING;
                            newCard.scheduled_days = 1;
                            newCard.lapses = (card.lapses || 0) + 1;
                        } else {
                            newCard.state = rating === Rating.HARD ? State.LEARNING : State.REVIEW;
                            const interval = this.calculateInterval(newCard.stability);
                            newCard.scheduled_days = Math.min(Math.round(interval), this.maximumInterval);
                            
                            if (rating === Rating.EASY) {
                                newCard.scheduled_days = Math.round(newCard.scheduled_days * this.easyBonus);
                            } else if (rating === Rating.HARD) {
                                newCard.scheduled_days = Math.round(newCard.scheduled_days * this.hardInterval);
                            }
                        }
                    } else {
                        const retrievability = this.calculateRetrievability(elapsed_days, card.stability);
                        newCard.elapsed_days = elapsed_days;
                        
                        if (rating === Rating.AGAIN) {
                            newCard.stability = this.calculateForgetStability(card.difficulty, card.stability, retrievability);
                            newCard.difficulty = this.calculateNextDifficulty(card.difficulty, rating);
                            newCard.state = State.RELEARNING;
                            newCard.scheduled_days = 1;
                            newCard.lapses = (card.lapses || 0) + 1;
                        } else {
                            newCard.stability = this.calculateNextStability(card.difficulty, card.stability, retrievability, rating);
                            newCard.difficulty = this.calculateNextDifficulty(card.difficulty, rating);
                            newCard.state = State.REVIEW;
                            
                            let interval = this.calculateInterval(newCard.stability);
                            
                            if (rating === Rating.EASY) {
                                interval *= this.easyBonus;
                            } else if (rating === Rating.HARD) {
                                interval *= this.hardInterval;
                            }
                            
                            newCard.scheduled_days = Math.min(Math.round(interval), this.maximumInterval);
                        }
                    }
                    
                    newCard.reps = (card.reps || 0) + 1;
                    newCard.lapses = Math.max(newCard.lapses || 0, 0);
                    newCard.stability = Math.max(newCard.stability, 0.01);
                    newCard.difficulty = Math.max(Math.min(newCard.difficulty, 10), 1);
                    newCard.scheduled_days = Math.max(Math.min(newCard.scheduled_days, this.maximumInterval), 1);
                    newCard.last_review = reviewTime.toISOString();
                    newCard.due = new Date(now + newCard.scheduled_days * 24 * 60 * 60 * 1000);

                    if (this.enableDebug) {
                        console.log('FSRS Debug:', {
                            rating,
                            elapsed_days: elapsed_days.toFixed(2),
                            old_stability: card.stability.toFixed(3),
                            new_stability: newCard.stability.toFixed(3),
                            old_difficulty: card.difficulty.toFixed(3),
                            new_difficulty: newCard.difficulty.toFixed(3),
                            interval: newCard.scheduled_days,
                            retrievability: card.state !== State.NEW ? this.calculateRetrievability(elapsed_days, card.stability).toFixed(3) : 1
                        });
                    }

                    return newCard;
                    
                } catch (error) {
                    console.error('FSRSå¾©ç¿’å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼:', error);
                    
                    const fallbackCard = { ...card };
                    fallbackCard.reps = (card.reps || 0) + 1;
                    fallbackCard.last_review = reviewTime.toISOString();
                    
                    if (rating === Rating.AGAIN) {
                        fallbackCard.scheduled_days = 1;
                        fallbackCard.lapses = (card.lapses || 0) + 1;
                    } else {
                        fallbackCard.scheduled_days = Math.max(Math.round((card.scheduled_days || 1) * (rating - 1)), 1);
                    }
                    
                    fallbackCard.due = new Date(reviewTime.getTime() + fallbackCard.scheduled_days * 24 * 60 * 60 * 1000);
                    
                    return fallbackCard;
                }
            }

            setDebugMode(enabled) {
                this.enableDebug = enabled;
            }

            clearCache() {
                this.intervalCache.clear();
                this.retrievabilityCache.clear();
            }
        }

        /**
         * GitHub APIç®¡ç†ã‚¯ãƒ©ã‚¹
         */
        class GitHubManager {
            constructor() {
                this.token = null;
                this.owner = null;
                this.repo = null;
                this.yamlPath = null;
                this.branch = 'main';
                this.baseUrl = 'https://api.github.com';
                this.isConnected = false;
                
                this.loadSettings();
            }

            // è¨­å®šã®ä¿å­˜
            saveSettings() {
                const settings = {
                    token: this.token,
                    owner: this.owner,
                    repo: this.repo,
                    yamlPath: this.yamlPath,
                    branch: this.branch
                };
                
                // ç°¡å˜ãªæš—å·åŒ–ï¼ˆBase64ï¼‰
                const encoded = btoa(JSON.stringify(settings));
                localStorage.setItem('fsrs_github_settings', encoded);
            }

            // è¨­å®šã®èª­ã¿è¾¼ã¿
            loadSettings() {
                try {
                    const encoded = localStorage.getItem('fsrs_github_settings');
                    if (encoded) {
                        const settings = JSON.parse(atob(encoded));
                        this.token = settings.token;
                        this.owner = settings.owner;
                        this.repo = settings.repo;
                        this.yamlPath = settings.yamlPath;
                        this.branch = settings.branch || 'main';
                    }
                } catch (error) {
                    console.warn('è¨­å®šã®èª­ã¿è¾¼ã¿ã«å¤±æ•—:', error);
                }
            }

            // æ¥ç¶šãƒ†ã‚¹ãƒˆ
            async testConnection() {
                if (!this.token || !this.owner || !this.repo) {
                    throw new Error('å¿…è¦ãªè¨­å®šãŒä¸è¶³ã—ã¦ã„ã¾ã™');
                }

                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}`, {
                        headers: {
                            'Authorization': `token ${this.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });

                    if (!response.ok) {
                        if (response.status === 401) {
                            throw new Error('èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚Personal Access Tokenã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                        } else if (response.status === 404) {
                            throw new Error('ãƒªãƒã‚¸ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚ªãƒ¼ãƒŠãƒ¼åã¨ãƒªãƒã‚¸ãƒˆãƒªåã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                        } else {
                            throw new Error(`GitHub API ã‚¨ãƒ©ãƒ¼: ${response.status} ${response.statusText}`);
                        }
                    }

                    const repoData = await response.json();
                    this.isConnected = true;
                    return {
                        success: true,
                        message: `âœ… æ¥ç¶šæˆåŠŸ: ${repoData.full_name}`,
                        repoData
                    };

                } catch (error) {
                    this.isConnected = false;
                    throw error;
                }
            }

            // YAMLãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
            async loadYAML() {
                if (!this.isConnected) {
                    await this.testConnection();
                }

                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/contents/${this.yamlPath}?ref=${this.branch}`, {
                        headers: {
                            'Authorization': `token ${this.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });

                    if (!response.ok) {
                        if (response.status === 404) {
                            // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ç©ºã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
                            return {
                                success: true,
                                data: { terms: [] },
                                message: 'YAMLãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã™ã€‚',
                                isNew: true
                            };
                        } else {
                            throw new Error(`ãƒ•ã‚¡ã‚¤ãƒ«å–å¾—ã‚¨ãƒ©ãƒ¼: ${response.status} ${response.statusText}`);
                        }
                    }

                    const fileData = await response.json();
                    
                    // Base64ãƒ‡ã‚³ãƒ¼ãƒ‰ï¼ˆUTF-8å¯¾å¿œï¼‰
                    let content;
                    try {
                        // Base64ã‚’ãƒã‚¤ãƒŠãƒªã«å¤‰æ›
                        const binaryString = atob(fileData.content);
                        
                        // ãƒã‚¤ãƒŠãƒªã‚’Uint8Arrayã«å¤‰æ›
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        
                        // UTF-8ã¨ã—ã¦æ­£ã—ããƒ‡ã‚³ãƒ¼ãƒ‰
                        content = new TextDecoder('utf-8').decode(bytes);
                        
                    } catch (decodeError) {
                        console.warn('UTF-8ãƒ‡ã‚³ãƒ¼ãƒ‰ã§ã‚¨ãƒ©ãƒ¼ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ã‚’å®Ÿè¡Œ:', decodeError);
                        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®æ–¹æ³•
                        content = decodeURIComponent(escape(atob(fileData.content)));
                    }

                    // åˆ¶å¾¡æ–‡å­—ã‚„ä¸æ­£ãªæ–‡å­—ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    content = this.cleanYAMLContent(content);

                    let data;
                    try {
                        data = jsyaml.load(content);
                    } catch (yamlError) {
                        console.error('YAMLè§£æã‚¨ãƒ©ãƒ¼:', yamlError);
                        console.log('å•é¡Œã®ã‚ã‚‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„:', content.substring(0, 500));
                        throw new Error(`YAMLè§£æã‚¨ãƒ©ãƒ¼: ${yamlError.message}`);
                    }

                    return {
                        success: true,
                        data: data || { terms: [] },
                        message: 'âœ… GitHubã‹ã‚‰YAMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ',
                        sha: fileData.sha, // æ›´æ–°ã«å¿…è¦
                        isNew: false
                    };

                } catch (error) {
                    throw new Error(`YAMLèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                }
            }

            // YAMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            cleanYAMLContent(content) {
                // åˆ¶å¾¡æ–‡å­—ï¼ˆå°åˆ·ä¸å¯èƒ½æ–‡å­—ï¼‰ã‚’é™¤å»
                content = content.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
                
                // BOMã‚’é™¤å»
                content = content.replace(/^\uFEFF/, '');
                
                // ä¸æ­£ãªUTF-8ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ç½®æ›
                content = content.replace(/\uFFFD/g, '');
                
                // æ”¹è¡Œã®æ­£è¦åŒ–
                content = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                
                return content;
            }

            // YAMLãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜
            async saveYAML(data, commitMessage = null) {
                if (!this.isConnected) {
                    await this.testConnection();
                }

                try {
                    // ã¾ãšç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®æƒ…å ±ã‚’å–å¾—ï¼ˆSHAå€¤ãŒå¿…è¦ï¼‰
                    let currentSha = null;
                    let isUpdate = false;

                    try {
                        const currentResponse = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/contents/${this.yamlPath}?ref=${this.branch}`, {
                            headers: {
                                'Authorization': `token ${this.token}`,
                                'Accept': 'application/vnd.github.v3+json'
                            }
                        });

                        if (currentResponse.ok) {
                            const currentData = await currentResponse.json();
                            currentSha = currentData.sha;
                            isUpdate = true;
                        }
                    } catch (error) {
                        // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯æ–°è¦ä½œæˆ
                        console.log('æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã™');
                    }

                    // YAMLãƒ‡ãƒ¼ã‚¿ã®æº–å‚™
                    const yamlData = {
                        version: "FSRS-v6",
                        created: data.created || new Date().toISOString(),
                        updated: new Date().toISOString(),
                        terms: data.terms.map(term => ({
                            ...term,
                            fsrs: {
                                ...term.fsrs,
                                due: typeof term.fsrs.due === 'string' ? term.fsrs.due : term.fsrs.due.toISOString(),
                                last_review: term.fsrs.last_review
                            }
                        }))
                    };

                    let yamlString;
                    try {
                        yamlString = jsyaml.dump(yamlData, {
                            defaultFlowStyle: false,
                            indent: 2,
                            lineWidth: -1,
                            noRefs: true,
                            skipInvalid: true
                        });
                    } catch (yamlError) {
                        throw new Error(`YAMLç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${yamlError.message}`);
                    }

                    // UTF-8ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’ç¢ºå®Ÿã«ã™ã‚‹
                    let content;
                    try {
                        // UTF-8 Uint8Arrayã«å¤‰æ›
                        const encoder = new TextEncoder();
                        const utf8Bytes = encoder.encode(yamlString);
                        
                        // Uint8Arrayã‚’Base64ã«å¤‰æ›
                        const binaryString = Array.from(utf8Bytes, byte => String.fromCharCode(byte)).join('');
                        content = btoa(binaryString);
                        
                    } catch (encodeError) {
                        console.warn('UTF-8ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã§ã‚¨ãƒ©ãƒ¼ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ã‚’å®Ÿè¡Œ:', encodeError);
                        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®æ–¹æ³•
                        content = btoa(unescape(encodeURIComponent(yamlString)));
                    }

                    // ã‚³ãƒŸãƒƒãƒˆãƒ‡ãƒ¼ã‚¿ã®æº–å‚™
                    const commitData = {
                        message: commitMessage || `${isUpdate ? 'æ›´æ–°' : 'è¿½åŠ '}: FSRSç”¨èªãƒ‡ãƒ¼ã‚¿ (${new Date().toLocaleString('ja-JP')})`,
                        content: content,
                        branch: this.branch
                    };

                    if (currentSha) {
                        commitData.sha = currentSha;
                    }

                    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒŸãƒƒãƒˆ
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/contents/${this.yamlPath}`, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${this.token}`,
                            'Content-Type': 'application/json',
                            'Accept': 'application/vnd.github.v3+json'
                        },
                        body: JSON.stringify(commitData)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`ä¿å­˜ã‚¨ãƒ©ãƒ¼: ${response.status} - ${errorData.message || response.statusText}`);
                    }

                    const result = await response.json();
                    return {
                        success: true,
                        message: `âœ… GitHubã«ä¿å­˜ã—ã¾ã—ãŸ: ${result.commit.message}`,
                        commitData: result
                    };

                } catch (error) {
                    throw new Error(`YAMLä¿å­˜ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                }
            }

            // è¨­å®šã®ã‚¯ãƒªã‚¢
            clearSettings() {
                localStorage.removeItem('fsrs_github_settings');
                this.token = null;
                this.owner = null;
                this.repo = null;
                this.yamlPath = null;
                this.branch = 'main';
                this.isConnected = false;
            }
        }

        /**
         * ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹
         */
        class TermMemorizationApp {
            constructor() {
                this.terms = [];
                this.currentMode = 'upload';
                this.currentQuizTerm = null;
                this.currentDetailTerm = null;
                this.fsrs = new FSRSCalculator();
                this.showingDefinition = false;
                this.github = new GitHubManager();
                this.lastSyncTime = null;
                this.hasUnsavedChanges = false;
                this.isOnline = navigator.onLine;
                
                this.initializeEventListeners();
                this.updateConnectionStatus();
                this.setupOfflineDetection();
                this.loadLocalBackup();
            }

            // é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
            showNotification(message, type = 'info', duration = 3000) {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.className = `notification ${type}`;
                notification.classList.add('show');

                setTimeout(() => {
                    notification.classList.remove('show');
                }, duration);
            }

            // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ¤œå‡º
            setupOfflineDetection() {
                const offlineIndicator = document.getElementById('offlineIndicator');
                
                window.addEventListener('online', () => {
                    this.isOnline = true;
                    offlineIndicator.style.display = 'none';
                    this.showNotification('ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã«å¾©å¸°ã—ã¾ã—ãŸ', 'success');
                    this.updateConnectionStatus();
                });

                window.addEventListener('offline', () => {
                    this.isOnline = false;
                    offlineIndicator.style.display = 'block';
                    this.showNotification('ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã§ã™', 'info');
                    this.updateConnectionStatus();
                });

                // åˆæœŸçŠ¶æ…‹ã®è¨­å®š
                if (!this.isOnline) {
                    offlineIndicator.style.display = 'block';
                }
            }

            // ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®èª­ã¿è¾¼ã¿
            loadLocalBackup() {
                try {
                    const backup = localStorage.getItem('fsrs_local_backup');
                    if (backup) {
                        const data = JSON.parse(backup);
                        if (data.terms && Array.isArray(data.terms) && data.terms.length > 0) {
                            const backupDate = new Date(data.timestamp).toLocaleString('ja-JP');
                            console.log(`ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’æ¤œå‡º: ${backupDate}`);
                            // å¿…è¦ã«å¿œã˜ã¦å¾©å…ƒã®ææ¡ˆã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è¡¨ç¤º
                        }
                    }
                } catch (error) {
                    console.warn('ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                }
            }

            // ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ä¿å­˜
            saveLocalBackup() {
                try {
                    const backup = {
                        terms: this.terms,
                        timestamp: new Date().toISOString(),
                        version: "FSRS-v6"
                    };
                    localStorage.setItem('fsrs_local_backup', JSON.stringify(backup));
                    console.log('ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
                } catch (error) {
                    console.warn('ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                }
            }

            // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
            validateTermsData(terms) {
                const errors = [];
                
                if (!Array.isArray(terms)) {
                    errors.push('ç”¨èªãƒ‡ãƒ¼ã‚¿ãŒé…åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“');
                    return errors;
                }

                terms.forEach((term, index) => {
                    if (!term.term || typeof term.term !== 'string') {
                        errors.push(`ç”¨èª${index + 1}: ç”¨èªåãŒç„¡åŠ¹ã§ã™`);
                    }
                    
                    if (!term.description || typeof term.description !== 'string') {
                        errors.push(`ç”¨èª${index + 1}: èª¬æ˜ãŒç„¡åŠ¹ã§ã™`);
                    }
                    
                    if (!term.fsrs || typeof term.fsrs !== 'object') {
                        errors.push(`ç”¨èª${index + 1}: FSRSãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™`);
                    } else {
                        const fsrs = term.fsrs;
                        if (typeof fsrs.stability !== 'number' || fsrs.stability < 0) {
                            errors.push(`ç”¨èª${index + 1}: å®‰å®šæ€§ã®å€¤ãŒç„¡åŠ¹ã§ã™`);
                        }
                        if (typeof fsrs.difficulty !== 'number' || fsrs.difficulty < 1 || fsrs.difficulty > 10) {
                            errors.push(`ç”¨èª${index + 1}: é›£æ˜“åº¦ã®å€¤ãŒç„¡åŠ¹ã§ã™`);
                        }
                    }
                });

                return errors;
            }

            initializeEventListeners() {
                // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
                document.getElementById('yamlFile').addEventListener('change', (e) => {
                    this.handleFileUpload(e);
                });

                // GitHubè¨­å®š
                document.getElementById('githubSetupBtn').addEventListener('click', () => {
                    this.showGitHubSetup();
                });

                document.getElementById('testConnectionBtn').addEventListener('click', () => {
                    this.testGitHubConnection();
                });

                document.getElementById('saveGitHubSettingsBtn').addEventListener('click', () => {
                    this.saveGitHubSettings();
                });

                document.getElementById('closeSetupBtn').addEventListener('click', () => {
                    this.closeGitHubSetup();
                });

                // GitHubæ“ä½œ
                document.getElementById('loadFromGitHubBtn').addEventListener('click', () => {
                    this.loadFromGitHub();
                });

                document.getElementById('saveToGitHubBtn').addEventListener('click', () => {
                    this.saveToGitHub();
                });

                // YAMLä¿®å¾©æ©Ÿèƒ½
                document.getElementById('repairYamlBtn')?.addEventListener('click', () => {
                    this.repairYamlFile();
                });

                // ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½
                document.getElementById('debugBtn')?.addEventListener('click', () => {
                    this.showDebugInfo();
                });

                // ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
                document.getElementById('dictionaryMode').addEventListener('click', () => {
                    this.switchMode('dictionary');
                });

                document.getElementById('quizMode').addEventListener('click', () => {
                    this.switchMode('quiz');
                });

                // ã‚¯ã‚¤ã‚ºæ“ä½œ
                document.getElementById('againBtn').addEventListener('click', () => {
                    this.handleQuizAnswer(Rating.AGAIN);
                });

                document.getElementById('hardBtn').addEventListener('click', () => {
                    this.handleQuizAnswer(Rating.HARD);
                });

                document.getElementById('goodBtn').addEventListener('click', () => {
                    this.handleQuizAnswer(Rating.GOOD);
                });

                document.getElementById('easyBtn').addEventListener('click', () => {
                    this.handleQuizAnswer(Rating.EASY);
                });

                // ç”¨èªã‚¯ãƒªãƒƒã‚¯ã§å®šç¾©è¡¨ç¤º
                document.getElementById('quizTerm').addEventListener('click', () => {
                    this.toggleDefinition();
                });

                // è©³ç´°ç”»é¢ã‹ã‚‰æˆ»ã‚‹
                document.getElementById('backBtn').addEventListener('click', () => {
                    this.switchMode('dictionary');
                });

                // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                document.getElementById('downloadBtn').addEventListener('click', () => {
                    this.downloadUpdatedYAML();
                });

                // ãƒ˜ãƒ«ãƒ—
                document.getElementById('helpBtn').addEventListener('click', () => {
                    this.showHelp();
                });

                // ãƒ‡ãƒãƒƒã‚°ç”¨ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'D' && e.shiftKey) {
                        const debugDiv = document.getElementById('debugInfo');
                        debugDiv.style.display = debugDiv.style.display === 'none' ? 'block' : 'none';
                        this.fsrs.setDebugMode(debugDiv.style.display === 'block');
                    } else if (e.key === 'P' && e.shiftKey) {
                        this.showPerformanceStats();
                    } else if (e.key === 'C' && e.shiftKey) {
                        this.fsrs.clearCache();
                        alert('ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
                    }
                });
            }

            updateConnectionStatus() {
                const statusDiv = document.getElementById('connectionStatus');
                const loadBtn = document.getElementById('loadFromGitHubBtn');
                const saveBtn = document.getElementById('saveToGitHubBtn');

                if (this.github.isConnected) {
                    statusDiv.className = 'connection-status status-connected';
                    statusDiv.innerHTML = `âœ… GitHubæ¥ç¶šæ¸ˆã¿: ${this.github.owner}/${this.github.repo}`;
                    loadBtn.disabled = false;
                    saveBtn.disabled = this.terms.length === 0;
                } else if (this.github.token && this.github.owner && this.github.repo) {
                    statusDiv.className = 'connection-status status-disconnected';
                    statusDiv.innerHTML = 'âš ï¸ GitHubè¨­å®šæ¸ˆã¿ï¼ˆæœªæ¥ç¶šï¼‰';
                    loadBtn.disabled = false;
                    saveBtn.disabled = true;
                } else {
                    statusDiv.className = 'connection-status status-disconnected';
                    statusDiv.innerHTML = 'âŒ GitHubæœªè¨­å®š';
                    loadBtn.disabled = true;
                    saveBtn.disabled = true;
                }
            }

            showGitHubSetup() {
                // ç¾åœ¨ã®è¨­å®šå€¤ã‚’ãƒ•ã‚©ãƒ¼ãƒ ã«ã‚»ãƒƒãƒˆ
                document.getElementById('githubToken').value = this.github.token || '';
                document.getElementById('repoOwner').value = this.github.owner || '';
                document.getElementById('repoName').value = this.github.repo || '';
                document.getElementById('yamlPath').value = this.github.yamlPath || 'data/terms.yaml';
                document.getElementById('mainBranch').value = this.github.branch || 'main';

                this.switchMode('github-setup');
            }

            async testGitHubConnection() {
                const testBtn = document.getElementById('testConnectionBtn');
                const originalText = testBtn.textContent;
                
                try {
                    testBtn.disabled = true;
                    testBtn.innerHTML = '<span class="loading-spinner"></span> æ¥ç¶šä¸­...';
                    
                    // ãƒ•ã‚©ãƒ¼ãƒ ã®å€¤ã‚’ä¸€æ™‚çš„ã«è¨­å®š
                    this.github.token = document.getElementById('githubToken').value.trim();
                    this.github.owner = document.getElementById('repoOwner').value.trim();
                    this.github.repo = document.getElementById('repoName').value.trim();
                    this.github.yamlPath = document.getElementById('yamlPath').value.trim();
                    this.github.branch = document.getElementById('mainBranch').value.trim() || 'main';

                    const result = await this.github.testConnection();
                    
                    this.showNotification(result.message, 'success');
                    this.updateConnectionStatus();
                    
                } catch (error) {
                    console.error('æ¥ç¶šãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
                    this.showNotification(`æ¥ç¶šã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    this.github.isConnected = false;
                    this.updateConnectionStatus();
                } finally {
                    testBtn.disabled = false;
                    testBtn.textContent = originalText;
                }
            }

            saveGitHubSettings() {
                // ãƒ•ã‚©ãƒ¼ãƒ ã®å€¤ã‚’ä¿å­˜
                this.github.token = document.getElementById('githubToken').value.trim();
                this.github.owner = document.getElementById('repoOwner').value.trim();
                this.github.repo = document.getElementById('repoName').value.trim();
                this.github.yamlPath = document.getElementById('yamlPath').value.trim();
                this.github.branch = document.getElementById('mainBranch').value.trim() || 'main';

                if (!this.github.token || !this.github.owner || !this.github.repo || !this.github.yamlPath) {
                    this.showNotification('ã™ã¹ã¦ã®å¿…é ˆé …ç›®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
                    return;
                }

                this.github.saveSettings();
                this.showNotification('GitHubè¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ', 'success');
                this.updateConnectionStatus();
                this.closeGitHubSetup();
            }

            closeGitHubSetup() {
                this.switchMode('upload');
            }

            async loadFromGitHub() {
                const loadBtn = document.getElementById('loadFromGitHubBtn');
                const originalText = loadBtn.textContent;
                
                if (!this.isOnline) {
                    this.showNotification('ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã®ãŸã‚èª­ã¿è¾¼ã¿ã§ãã¾ã›ã‚“', 'error');
                    return;
                }
                
                try {
                    loadBtn.disabled = true;
                    loadBtn.innerHTML = '<span class="loading-spinner"></span> èª­ã¿è¾¼ã¿ä¸­...';
                    
                    const result = await this.github.loadYAML();
                    
                    if (result.data && result.data.terms && Array.isArray(result.data.terms)) {
                        // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
                        const validationErrors = this.validateTermsData(result.data.terms);
                        if (validationErrors.length > 0) {
                            console.warn('ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã®è­¦å‘Š:', validationErrors);
                            this.showNotification(`ãƒ‡ãƒ¼ã‚¿ã«${validationErrors.length}å€‹ã®è­¦å‘ŠãŒã‚ã‚Šã¾ã™`, 'warning');
                        }
                        
                        let conversionCount = 0;
                        
                        this.terms = result.data.terms.map(term => {
                            if (!term.fsrs || typeof term.fsrs !== 'object') {
                                conversionCount++;
                                const fsrsCard = this.fsrs.createEmptyCard();
                                return {
                                    term: term.term || '',
                                    description: term.description || '',
                                    miss_count: term.miss_count || 0,
                                    fsrs: fsrsCard
                                };
                            } else {
                                const fsrsData = { ...term.fsrs };
                                
                                try {
                                    fsrsData.due = term.fsrs.due ? new Date(term.fsrs.due) : new Date();
                                    if (isNaN(fsrsData.due)) {
                                        fsrsData.due = new Date();
                                    }
                                } catch (e) {
                                    fsrsData.due = new Date();
                                }
                                
                                fsrsData.stability = Math.max(fsrsData.stability || 0, 0);
                                fsrsData.difficulty = Math.max(Math.min(fsrsData.difficulty || 5, 10), 1);
                                fsrsData.reps = Math.max(fsrsData.reps || 0, 0);
                                fsrsData.lapses = Math.max(fsrsData.lapses || 0, 0);
                                fsrsData.state = [0, 1, 2, 3].includes(fsrsData.state) ? fsrsData.state : 0;
                                
                                return {
                                    term: term.term || '',
                                    description: term.description || '',
                                    miss_count: term.miss_count || 0,
                                    fsrs: fsrsData
                                };
                            }
                        });
                        
                        this.enableControls();
                        this.switchMode('dictionary');
                        this.lastSyncTime = new Date().toISOString();
                        this.hasUnsavedChanges = false;
                        this.saveLocalBackup();
                        
                        let message = `${this.terms.length}å€‹ã®ç”¨èªã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`;
                        if (conversionCount > 0) {
                            message += ` (${conversionCount}å€‹ã‚’æ–°å½¢å¼ã«å¤‰æ›)`;
                        }
                        if (result.isNew) {
                            message += '\nåˆå›ä½¿ç”¨æ™‚ã¯ä¿å­˜ãƒœã‚¿ãƒ³ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¦ãã ã•ã„';
                        }
                        
                        this.showNotification(message, 'success');
                        
                    } else {
                        throw new Error('ç„¡åŠ¹ãªYAMLãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™ã€‚termsé…åˆ—ãŒå¿…è¦ã§ã™ã€‚');
                    }
                    
                } catch (error) {
                    console.error('GitHubèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                    this.showNotification(`èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    
                    // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚ã¯ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ææ¡ˆ
                    if (!this.isOnline) {
                        const backup = localStorage.getItem('fsrs_local_backup');
                        if (backup && confirm('ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½¿ç”¨ã—ã¾ã™ã‹ï¼Ÿ')) {
                            this.loadFromLocalBackup();
                        }
                    }
                } finally {
                    loadBtn.disabled = false;
                    loadBtn.textContent = originalText;
                    this.updateConnectionStatus();
                }
            }

            async saveToGitHub() {
                const saveBtn = document.getElementById('saveToGitHubBtn');
                const originalText = saveBtn.textContent;
                
                if (!this.isOnline) {
                    this.showNotification('ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã®ãŸã‚ä¿å­˜ã§ãã¾ã›ã‚“', 'error');
                    this.saveLocalBackup(); // ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¯ä¿å­˜
                    return;
                }
                
                try {
                    saveBtn.disabled = true;
                    saveBtn.innerHTML = '<span class="loading-spinner"></span> ä¿å­˜ä¸­...';
                    
                    const yamlData = {
                        version: "FSRS-v6",
                        created: new Date().toISOString(),
                        terms: this.terms
                    };

                    const result = await this.github.saveYAML(yamlData);
                    
                    this.lastSyncTime = new Date().toISOString();
                    this.hasUnsavedChanges = false;
                    this.saveLocalBackup();
                    this.updateBackupInfo();
                    
                    this.showNotification('GitHubã«ä¿å­˜ã—ã¾ã—ãŸ', 'success');
                    
                } catch (error) {
                    console.error('GitHubä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                    this.showNotification(`ä¿å­˜ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¯ä¿å­˜
                    this.saveLocalBackup();
                } finally {
                    saveBtn.disabled = false;
                    saveBtn.textContent = originalText;
                }
            }

            loadFromLocalBackup() {
                try {
                    const backup = localStorage.getItem('fsrs_local_backup');
                    if (backup) {
                        const data = JSON.parse(backup);
                        this.terms = data.terms;
                        this.enableControls();
                        this.switchMode('dictionary');
                        this.showNotification('ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒã—ã¾ã—ãŸ', 'info');
                    }
                } catch (error) {
                    this.showNotification('ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
                }
            }

            async handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    this.showNotification('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...', 'info');
                    
                    const text = await file.text();
                    const data = jsyaml.load(text);
                    
                    if (data && data.terms && Array.isArray(data.terms)) {
                        // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
                        const validationErrors = this.validateTermsData(data.terms);
                        if (validationErrors.length > 0) {
                            console.warn('ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã®è­¦å‘Š:', validationErrors);
                            this.showNotification(`ãƒ‡ãƒ¼ã‚¿ã«${validationErrors.length}å€‹ã®è­¦å‘ŠãŒã‚ã‚Šã¾ã™`, 'warning');
                        }
                        
                        let conversionCount = 0;
                        
                        this.terms = data.terms.map(term => {
                            if (!term.fsrs || typeof term.fsrs !== 'object') {
                                conversionCount++;
                                const fsrsCard = this.fsrs.createEmptyCard();
                                return {
                                    term: term.term || '',
                                    description: term.description || '',
                                    miss_count: term.miss_count || 0,
                                    fsrs: fsrsCard
                                };
                            } else {
                                const fsrsData = { ...term.fsrs };
                                
                                try {
                                    fsrsData.due = term.fsrs.due ? new Date(term.fsrs.due) : new Date();
                                    if (isNaN(fsrsData.due)) {
                                        fsrsData.due = new Date();
                                    }
                                } catch (e) {
                                    fsrsData.due = new Date();
                                }
                                
                                fsrsData.stability = Math.max(fsrsData.stability || 0, 0);
                                fsrsData.difficulty = Math.max(Math.min(fsrsData.difficulty || 5, 10), 1);
                                fsrsData.reps = Math.max(fsrsData.reps || 0, 0);
                                fsrsData.lapses = Math.max(fsrsData.lapses || 0, 0);
                                fsrsData.state = [0, 1, 2, 3].includes(fsrsData.state) ? fsrsData.state : 0;
                                
                                return {
                                    term: term.term || '',
                                    description: term.description || '',
                                    miss_count: term.miss_count || 0,
                                    fsrs: fsrsData
                                };
                            }
                        });
                        
                        this.enableControls();
                        this.switchMode('dictionary');
                        this.hasUnsavedChanges = true;
                        this.saveLocalBackup();
                        
                        let message = `${this.terms.length}å€‹ã®ç”¨èªã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`;
                        if (conversionCount > 0) {
                            message += ` (${conversionCount}å€‹ã‚’æ–°å½¢å¼ã«å¤‰æ›)`;
                        }
                        
                        this.showNotification(message, 'success');
                        
                    } else {
                        throw new Error('ç„¡åŠ¹ãªYAMLãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™ã€‚termsé…åˆ—ãŒå¿…è¦ã§ã™ã€‚');
                    }
                } catch (error) {
                    console.error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                    this.showNotification(`ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }

            enableControls() {
                document.getElementById('dictionaryMode').disabled = false;
                document.getElementById('quizMode').disabled = false;
                document.getElementById('downloadBtn').disabled = false;
                this.updateConnectionStatus();
            }

            switchMode(mode) {
                // å…¨ã¦ã®ç”»é¢ã‚’éè¡¨ç¤º
                document.getElementById('uploadScreen').style.display = 'none';
                document.getElementById('githubSetupScreen').style.display = 'none';
                document.getElementById('dictionaryScreen').style.display = 'none';
                document.getElementById('quizScreen').style.display = 'none';
                document.getElementById('detailScreen').style.display = 'none';

                this.currentMode = mode;

                switch (mode) {
                    case 'github-setup':
                        document.getElementById('githubSetupScreen').style.display = 'block';
                        break;
                    case 'dictionary':
                        this.showDictionaryMode();
                        break;
                    case 'quiz':
                        this.showQuizMode();
                        break;
                    case 'detail':
                        this.showDetailMode();
                        break;
                    default:
                        document.getElementById('uploadScreen').style.display = 'block';
                        break;
                }
            }

            showDictionaryMode() {
                document.getElementById('dictionaryScreen').style.display = 'block';
                this.updateStats();
                this.renderTermsGrid();
            }

            updateStats() {
                const totalTerms = this.terms.length;
                const now = new Date();
                const dueTerms = this.terms.filter(term => {
                    return new Date(term.fsrs.due) <= now;
                }).length;
                const totalReviews = this.terms.reduce((sum, term) => sum + term.fsrs.reps, 0);
                
                // æ–°ã—ã„çµ±è¨ˆè¨ˆç®—
                const avgDifficulty = totalTerms > 0 ? 
                    this.terms.reduce((sum, term) => sum + (term.fsrs.difficulty || 5), 0) / totalTerms : 0;
                
                // ç¿’å¾—æ¸ˆã¿ç”¨èªï¼ˆå®‰å®šæ€§ãŒ30æ—¥ä»¥ä¸Šã‹ã¤å¾©ç¿’å›æ•°ãŒ3å›ä»¥ä¸Šï¼‰
                const masteredTerms = this.terms.filter(term => 
                    term.fsrs.stability >= 30 && term.fsrs.reps >= 3
                ).length;
                
                // é€²æ—è¨ˆç®—ï¼ˆå…¨ç”¨èªã®ã†ã¡å°‘ãªãã¨ã‚‚1å›å¾©ç¿’æ¸ˆã¿ã®å‰²åˆï¼‰
                const reviewedTerms = this.terms.filter(term => term.fsrs.reps > 0).length;
                const progressPercentage = totalTerms > 0 ? Math.round((reviewedTerms / totalTerms) * 100) : 0;
                
                // DOMæ›´æ–°
                document.getElementById('totalTerms').textContent = totalTerms;
                document.getElementById('dueTerms').textContent = dueTerms;
                document.getElementById('totalReviews').textContent = totalReviews;
                document.getElementById('avgDifficulty').textContent = avgDifficulty.toFixed(1);
                document.getElementById('masteredTerms').textContent = masteredTerms;
                document.getElementById('progressPercentage').textContent = `${progressPercentage}%`;
                document.getElementById('progressFill').style.width = `${progressPercentage}%`;
                
                // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æƒ…å ±ã®æ›´æ–°
                this.updateBackupInfo();
            }

            updateBackupInfo() {
                const backupInfo = document.getElementById('backupInfo');
                const lastSyncTimeElement = document.getElementById('lastSyncTime');
                const unsavedChangesElement = document.getElementById('unsavedChanges');
                
                if (this.github.isConnected) {
                    backupInfo.style.display = 'block';
                    
                    if (this.lastSyncTime) {
                        lastSyncTimeElement.textContent = new Date(this.lastSyncTime).toLocaleString('ja-JP');
                    } else {
                        lastSyncTimeElement.textContent = 'æœªåŒæœŸ';
                    }
                    
                    unsavedChangesElement.textContent = this.hasUnsavedChanges ? 'ã‚ã‚Š' : 'ãªã—';
                    unsavedChangesElement.style.color = this.hasUnsavedChanges ? '#e53e3e' : '#48bb78';
                } else {
                    backupInfo.style.display = 'none';
                }
            }

            renderTermsGrid() {
                const grid = document.getElementById('termsGrid');
                grid.innerHTML = '';

                this.terms.forEach((term, index) => {
                    const card = document.createElement('div');
                    card.className = 'term-card';
                    
                    const nextReviewText = this.formatNextReview(new Date(term.fsrs.due));
                    
                    card.innerHTML = `
                        <div class="term-name">${this.escapeHtml(term.term)}</div>
                        <div class="term-stats">
                            <div class="stat-badge miss-count">å¾©ç¿’: ${term.fsrs.reps}å›</div>
                            <div class="stat-badge difficulty">é›£æ˜“åº¦: ${term.fsrs.difficulty.toFixed(1)}</div>
                            <div class="stat-badge next-review">æ¬¡å›: ${nextReviewText}</div>
                        </div>
                    `;
                    
                    card.addEventListener('click', () => {
                        this.showTermDetail(index);
                    });
                    
                    grid.appendChild(card);
                });
            }

            formatNextReview(nextReview) {
                const now = new Date();
                const diffTime = nextReview - now;
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                
                if (diffDays <= 0) return 'å¾©ç¿’äºˆå®š';
                if (diffDays === 1) return '1æ—¥å¾Œ';
                if (diffDays < 30) return `${diffDays}æ—¥å¾Œ`;
                if (diffDays < 365) return `${Math.floor(diffDays / 30)}ãƒ¶æœˆå¾Œ`;
                return `${Math.floor(diffDays / 365)}å¹´å¾Œ`;
            }

            showTermDetail(termIndex) {
                this.currentDetailTerm = termIndex;
                const term = this.terms[termIndex];
                
                const retrievability = term.fsrs.state !== State.NEW && term.fsrs.last_review
                    ? this.fsrs.calculateRetrievability(
                        (Date.now() - new Date(term.fsrs.last_review).getTime()) / (1000 * 60 * 60 * 24),
                        term.fsrs.stability
                    )
                    : 1;
                
                document.getElementById('detailTerm').textContent = term.term;
                document.getElementById('detailDescription').textContent = term.description;
                document.getElementById('detailDifficulty').textContent = term.fsrs.difficulty.toFixed(1);
                document.getElementById('detailStability').textContent = Math.round(term.fsrs.stability);
                document.getElementById('detailReviews').textContent = term.fsrs.reps;
                document.getElementById('detailRetrievability').textContent = (retrievability * 100).toFixed(1) + '%';
                
                this.switchMode('detail');
            }

            showDetailMode() {
                document.getElementById('detailScreen').style.display = 'block';
            }

            showQuizMode() {
                document.getElementById('quizScreen').style.display = 'block';
                this.showNextDueTerm();
            }

            showNextDueTerm() {
                if (this.terms.length === 0) return;
                
                const now = new Date();
                const dueTerms = this.terms
                    .map((term, index) => ({ term, index }))
                    .filter(({ term }) => new Date(term.fsrs.due) <= now)
                    .sort((a, b) => {
                        return new Date(a.term.fsrs.due) - new Date(b.term.fsrs.due);
                    });

                if (dueTerms.length === 0) {
                    this.currentQuizTerm = Math.floor(Math.random() * this.terms.length);
                } else {
                    this.currentQuizTerm = dueTerms[0].index;
                }

                this.showingDefinition = false;
                this.updateQuizDisplay();
            }

            updateQuizDisplay() {
                const term = this.terms[this.currentQuizTerm];
                document.getElementById('termText').textContent = term.term;
                document.getElementById('quizDefinition').textContent = term.description;
                
                const quizTerm = document.getElementById('quizTerm');
                const quizDefinition = document.getElementById('quizDefinition');
                
                if (this.showingDefinition) {
                    quizTerm.classList.add('show-definition');
                    quizDefinition.classList.add('visible');
                } else {
                    quizTerm.classList.remove('show-definition');
                    quizDefinition.classList.remove('visible');
                }

                if (this.fsrs.enableDebug) {
                    this.updateDebugInfo(term);
                }
            }

            updateDebugInfo(term) {
                const elapsed = term.fsrs.last_review 
                    ? (Date.now() - new Date(term.fsrs.last_review).getTime()) / (1000 * 60 * 60 * 24)
                    : 0;
                const retrievability = term.fsrs.state !== State.NEW && term.fsrs.last_review
                    ? this.fsrs.calculateRetrievability(elapsed, term.fsrs.stability)
                    : 1;

                const debugInfo = `
                    çŠ¶æ…‹: ${Object.keys(State)[term.fsrs.state]} | 
                    é›£æ˜“åº¦: ${term.fsrs.difficulty.toFixed(2)} | 
                    å®‰å®šæ€§: ${term.fsrs.stability.toFixed(2)}æ—¥ | 
                    çµŒé: ${elapsed.toFixed(1)}æ—¥ | 
                    æƒ³èµ·ç¢ºç‡: ${(retrievability * 100).toFixed(1)}% | 
                    å¾©ç¿’å›æ•°: ${term.fsrs.reps}
                `;
                document.getElementById('debugInfo').textContent = debugInfo;
            }

            toggleDefinition() {
                this.showingDefinition = !this.showingDefinition;
                this.updateQuizDisplay();
            }

            handleQuizAnswer(rating) {
                if (this.currentQuizTerm === null) return;

                const term = this.terms[this.currentQuizTerm];
                const updatedFsrs = this.fsrs.reviewCard(term.fsrs, rating);
                this.terms[this.currentQuizTerm].fsrs = updatedFsrs;

                // å¤‰æ›´ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
                this.hasUnsavedChanges = true;
                this.saveLocalBackup();
                this.updateBackupInfo();

                // 10å›ç­”ã”ã¨ã«ä¿å­˜ã‚’ææ¡ˆ
                const totalAnswers = this.terms.reduce((sum, term) => sum + term.fsrs.reps, 0);
                if (this.github.isConnected && this.isOnline && totalAnswers % 10 === 0 && this.hasUnsavedChanges) {
                    if (confirm('10å›ç­”ãŒå®Œäº†ã—ã¾ã—ãŸã€‚GitHubã«ä¿å­˜ã—ã¾ã™ã‹ï¼Ÿ')) {
                        this.saveToGitHub();
                    }
                }

                this.showNextDueTerm();
            }

            downloadUpdatedYAML() {
                try {
                    const yamlData = {
                        version: "FSRS-v6",
                        created: new Date().toISOString(),
                        terms: this.terms.map(term => ({
                            ...term,
                            fsrs: {
                                ...term.fsrs,
                                due: term.fsrs.due.toISOString(),
                                last_review: term.fsrs.last_review
                            }
                        }))
                    };

                    const yamlString = jsyaml.dump(yamlData, {
                        defaultFlowStyle: false,
                        indent: 2
                    });

                    const blob = new Blob([yamlString], { type: 'text/yaml' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `fsrs_terms_${new Date().toISOString().split('T')[0]}.yaml`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    URL.revokeObjectURL(url);
                    
                    alert('YAMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ');
                } catch (error) {
                    console.error('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', error);
                    alert('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                }
            }

            showPerformanceStats() {
                const totalTerms = this.terms.length;
                const totalReviews = this.terms.reduce((sum, term) => sum + (term.fsrs.reps || 0), 0);
                const avgDifficulty = totalTerms > 0 ? 
                    this.terms.reduce((sum, term) => sum + (term.fsrs.difficulty || 5), 0) / totalTerms : 0;
                const avgStability = totalTerms > 0 ? 
                    this.terms.reduce((sum, term) => sum + (term.fsrs.stability || 0), 0) / totalTerms : 0;
                
                const message = `
=== FSRS ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆ ===

ç”¨èªãƒ‡ãƒ¼ã‚¿:
- ç·ç”¨èªæ•°: ${totalTerms}
- ç·å¾©ç¿’å›æ•°: ${totalReviews}
- å¹³å‡é›£æ˜“åº¦: ${avgDifficulty.toFixed(2)}
- å¹³å‡å®‰å®šæ€§: ${avgStability.toFixed(2)}æ—¥

GitHubé€£æº:
- æ¥ç¶šçŠ¶æ…‹: ${this.github.isConnected ? 'æ¥ç¶šæ¸ˆã¿' : 'æœªæ¥ç¶š'}
- ãƒªãƒã‚¸ãƒˆãƒª: ${this.github.owner}/${this.github.repo}
- YAMLãƒ‘ã‚¹: ${this.github.yamlPath}

ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: ${(JSON.stringify(this.terms).length / 1024).toFixed(1)} KB

ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ:
- Shift+D: ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
- Shift+P: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆè¡¨ç¤º
- Shift+C: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
                `;
                
                alert(message);
            }

            showHelp() {
                const helpContent = `
=== FSRSç”¨èªæš—è¨˜ã‚¢ãƒ—ãƒª - GitHubé€£æºç‰ˆ v2.0 ãƒ˜ãƒ«ãƒ— ===

ğŸ¯ æ¦‚è¦:
æœ€æ–°ã®FSRS-6ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨GitHubé€£æºæ©Ÿèƒ½ã‚’æ­è¼‰ã—ãŸ
ç§‘å­¦çš„æ ¹æ‹ ã«åŸºã¥ãç”¨èªæš—è¨˜ã‚¢ãƒ—ãƒªã§ã™ã€‚

ğŸŒŸ æ–°æ©Ÿèƒ½ (v2.0):
- âœ… ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
- âœ… ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œã¨ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
- âœ… è©³ç´°å­¦ç¿’çµ±è¨ˆã¨ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹è¡¨ç¤º
- âœ… ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
- âœ… è‡ªå‹•ä¿å­˜ææ¡ˆã‚·ã‚¹ãƒ†ãƒ 
- âœ… ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– UIæ”¹å–„

ğŸ”§ GitHubé€£æºè¨­å®š:
1. Personal Access Tokenä½œæˆ
   - GitHub â†’ Settings â†’ Developer settings
   - "repo" ã‚¹ã‚³ãƒ¼ãƒ—ã§æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç”Ÿæˆ
2. ã‚¢ãƒ—ãƒªã§GitHubè¨­å®š
   - ãƒˆãƒ¼ã‚¯ãƒ³ã€ã‚ªãƒ¼ãƒŠãƒ¼ã€ãƒªãƒã‚¸ãƒˆãƒªåã‚’å…¥åŠ›
   - æ¥ç¶šãƒ†ã‚¹ãƒˆã§ç¢ºèª

ğŸ“ æ¨å¥¨ãƒªãƒã‚¸ãƒˆãƒªæ§‹æˆ:
your-repo/
â”œâ”€â”€ index.html          # ã“ã®ã‚¢ãƒ—ãƒª
â”œâ”€â”€ data/
â”‚   â””â”€â”€ terms.yaml     # ç”¨èªãƒ‡ãƒ¼ã‚¿
â””â”€â”€ README.md

ğŸ§  å­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ :
- ğŸ”´ Again: å®Œå…¨ã«å¿˜ã‚ŒãŸï¼ˆé–“éš”ãƒªã‚»ãƒƒãƒˆï¼‰
- ğŸŸ  Hard: å›°é›£ã ã£ãŸï¼ˆé–“éš”çŸ­ç¸®ï¼‰
- ğŸŸ¢ Good: æ¨™æº–çš„ï¼ˆé€šå¸¸é–“éš”ï¼‰
- ğŸ”µ Easy: ç°¡å˜ï¼ˆé–“éš”å»¶é•·ï¼‰

ğŸ“Š å­¦ç¿’çµ±è¨ˆ:
- ç·ç”¨èªæ•°: ç™»éŒ²ã•ã‚ŒãŸå…¨ç”¨èª
- å¾©ç¿’å¯¾è±¡: ä»Šæ—¥å¾©ç¿’ã™ã¹ãç”¨èª
- ç¿’å¾—æ¸ˆã¿: å®‰å®šæ€§30æ—¥ä»¥ä¸Šã®ç”¨èª
- é€²æ—ç‡: ä¸€åº¦ã§ã‚‚å¾©ç¿’ã—ãŸç”¨èªã®å‰²åˆ

ğŸ”„ ãƒ‡ãƒ¼ã‚¿åŒæœŸ:
- è‡ªå‹•: 10å›ç­”ã”ã¨ã«ä¿å­˜ææ¡ˆ
- æ‰‹å‹•: ã€ŒGitHubã«ä¿å­˜ã€ãƒœã‚¿ãƒ³
- ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—: ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«è‡ªå‹•ä¿å­˜
- ã‚ªãƒ•ãƒ©ã‚¤ãƒ³: ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã§ç¶™ç¶šå­¦ç¿’

ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£:
- Personal Access Tokenæš—å·åŒ–ä¿å­˜
- ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒªãƒã‚¸ãƒˆãƒªæ¨å¥¨
- ãƒˆãƒ¼ã‚¯ãƒ³å®šæœŸæ›´æ–°æ¨å¥¨

âŒ¨ï¸ ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ:
- Shift+D: ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
- Shift+P: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆè¡¨ç¤º
- Shift+C: FSRSã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢

ğŸŒ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ©Ÿèƒ½:
- ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è‡ªå‹•ä¿å­˜
- ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å­¦ç¿’ç¶™ç¶šå¯èƒ½
- ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¾©å¸°æ™‚ã«åŒæœŸææ¡ˆ

ğŸš¨ ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°:
1. æ¥ç¶šã‚¨ãƒ©ãƒ¼ â†’ ãƒˆãƒ¼ã‚¯ãƒ³ãƒ»ãƒªãƒã‚¸ãƒˆãƒªæƒ…å ±ç¢ºèª
2. ä¿å­˜ã‚¨ãƒ©ãƒ¼ â†’ æ¨©é™ãƒ»ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç¢ºèª
3. ãƒ‡ãƒ¼ã‚¿ã‚¨ãƒ©ãƒ¼ â†’ YAMLå½¢å¼ãƒ»æ•´åˆæ€§ç¢ºèª

ğŸ“± ãƒãƒ«ãƒãƒ‡ãƒã‚¤ã‚¹å¯¾å¿œ:
- ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³
- ã‚¯ãƒ©ã‚¦ãƒ‰åŒæœŸã§ãƒ‡ãƒã‚¤ã‚¹é–“å…±æœ‰
- å­¦ç¿’é€²æ—ã®ä¸€å…ƒç®¡ç†

ğŸ’¡ åŠ¹ç‡çš„ãªå­¦ç¿’ã®ã‚³ãƒ„:
- æ¯æ—¥ã®å¾©ç¿’ç¿’æ…£
- æ­£ç›´ãªè‡ªå·±è©•ä¾¡
- å®šæœŸçš„ãªãƒ‡ãƒ¼ã‚¿ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
- çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã®æ´»ç”¨

ğŸ”„ æ›´æ–°æƒ…å ± (v2.0):
- å¤§å¹…ãªUXæ”¹å–„
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å‘ä¸Š

Â© 2025 FSRS Community - Enhanced GitHub Edition
ç§‘å­¦çš„å­¦ç¿’ã§çŸ¥è­˜ã‚’ç¢ºå®Ÿã«å®šç€ã•ã›ã¾ã—ã‚‡ã†ï¼
                `;
                
                this.showNotification('ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤ºä¸­', 'info', 1000);
                setTimeout(() => {
                    alert(helpContent);
                }, 1000);
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            new TermMemorizationApp();
        });
    </script>
</body>
</html>