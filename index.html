<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FSRS用語暗記アプリ - GitHub連携版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 2rem;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #48bb78, #38a169);
        }

        .btn-danger {
            background: linear-gradient(45deg, #e53e3e, #c53030);
        }

        .btn-hard {
            background: linear-gradient(45deg, #ed8936, #dd6b20);
        }

        .btn-good {
            background: linear-gradient(45deg, #4299e1, #3182ce);
        }

        .btn-easy {
            background: linear-gradient(45deg, #48bb78, #38a169);
        }

        .btn-github {
            background: linear-gradient(45deg, #333, #24292e);
        }

        .file-input {
            display: none;
        }

        .file-label {
            padding: 12px 24px;
            background: linear-gradient(45deg, #ed8936, #dd6b20);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .main-content {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .upload-area {
            text-align: center;
            padding: 60px 20px;
            border: 2px dashed #cbd5e0;
            border-radius: 15px;
            background: #f7fafc;
        }

        .upload-area h2 {
            color: #4a5568;
            margin-bottom: 20px;
        }

        .github-setup {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
        }

        .github-setup h3 {
            color: #333;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .connection-status {
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-connected {
            background: #c6f6d5;
            color: #276749;
            border: 2px solid #9ae6b4;
        }

        .status-disconnected {
            background: #fed7d7;
            color: #c53030;
            border: 2px solid #fbb6ce;
        }

        .status-loading {
            background: #bee3f8;
            color: #2b6cb0;
            border: 2px solid #90cdf4;
        }

        .terms-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .term-card {
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .term-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            border-color: #667eea;
        }

        .term-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(45deg, #667eea, #764ba2);
        }

        .term-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 10px;
        }

        .term-stats {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .stat-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .miss-count {
            background: #fed7d7;
            color: #c53030;
        }

        .difficulty {
            background: #bee3f8;
            color: #2b6cb0;
        }

        .next-review {
            background: #c6f6d5;
            color: #276749;
        }

        .quiz-container {
            text-align: center;
            padding: 40px 20px;
        }

        .quiz-term {
            font-size: 2.5rem;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 20px;
            padding: 30px;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            border-radius: 15px;
            border: 2px solid #e2e8f0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quiz-term:hover {
            background: linear-gradient(135deg, #edf2f7 0%, #e2e8f0 100%);
            transform: scale(1.02);
        }

        .quiz-term.show-definition {
            background: linear-gradient(135deg, #e6fffa 0%, #b2f5ea 100%);
            border-color: #38b2ac;
        }

        .quiz-definition {
            font-size: 1.2rem;
            color: #4a5568;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px dashed #cbd5e0;
            display: none;
        }

        .quiz-definition.visible {
            display: block;
        }

        .quiz-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 30px;
        }

        .quiz-button {
            padding: 15px 25px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            min-width: 120px;
        }

        .quiz-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .detail-container {
            padding: 20px;
        }

        .detail-term {
            font-size: 2rem;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 20px;
            text-align: center;
        }

        .detail-description {
            font-size: 1.1rem;
            line-height: 1.6;
            color: #4a5568;
            background: #f7fafc;
            padding: 25px;
            border-radius: 12px;
            border-left: 4px solid #667eea;
            margin-bottom: 30px;
        }

        .back-button {
            display: block;
            margin: 0 auto;
        }

        .mode-indicator {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            display: inline-block;
        }

        .stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #4a5568;
        }

        .quiz-hint {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            padding: 10px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .debug-info {
            background: #f0f8ff;
            border: 1px solid #b0c4de;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 0.9rem;
            color: #483d8b;
        }

        .help-text {
            background: #fffacd;
            border: 1px solid #f0e68c;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-size: 0.9rem;
            color: #8b4513;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            max-width: 350px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background: linear-gradient(45deg, #48bb78, #38a169);
        }

        .notification.error {
            background: linear-gradient(45deg, #e53e3e, #c53030);
        }

        .notification.info {
            background: linear-gradient(45deg, #4299e1, #3182ce);
        }

        .offline-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: #ed8936;
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .data-backup-info {
            background: #f0f8ff;
            border: 2px solid #b0c4de;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-size: 0.9rem;
            color: #1e40af;
        }

        .quick-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .quick-stat {
            background: rgba(102, 126, 234, 0.1);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .quick-stat-number {
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
        }

        .quick-stat-label {
            font-size: 0.8rem;
            color: #4a5568;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }
            
            .quiz-term {
                font-size: 1.8rem;
            }
            
            .terms-grid {
                grid-template-columns: 1fr;
            }

            .quiz-buttons {
                flex-direction: column;
                align-items: center;
            }

            .stats {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🧠 FSRS用語暗記アプリ - GitHub連携版</h1>
            <div class="controls">
                <button id="githubSetupBtn" class="btn btn-github">🔧 GitHub設定</button>
                <label for="yamlFile" class="file-label">
                    📁 YAMLファイルを選択
                </label>
                <input type="file" id="yamlFile" class="file-input" accept=".yaml,.yml">
                <button id="loadFromGitHubBtn" class="btn btn-secondary" disabled>📥 GitHubから読み込み</button>
                <button id="dictionaryMode" class="btn" disabled>📚 辞書モード</button>
                <button id="quizMode" class="btn" disabled>🧠 クイズモード</button>
                <button id="saveToGitHubBtn" class="btn btn-secondary" disabled>💾 GitHubに保存</button>
                <button id="downloadBtn" class="btn btn-secondary" disabled>💾 YAMLダウンロード</button>
                <button id="helpBtn" class="btn" style="background: linear-gradient(45deg, #9f7aea, #805ad5);">❓ ヘルプ</button>
            </div>
        </div>

        <div class="main-content">
            <!-- GitHub設定画面 -->
            <div id="githubSetupScreen" style="display: none;">
                <div class="github-setup">
                    <h3>🔧 GitHub連携設定</h3>
                    
                    <div id="connectionStatus" class="connection-status status-disconnected">
                        ❌ GitHub未接続
                    </div>

                    <div class="form-group">
                        <label for="githubToken">Personal Access Token:</label>
                        <input type="password" id="githubToken" placeholder="ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx">
                        <div class="help-text">
                            <strong>Personal Access Tokenの作成方法:</strong><br>
                            1. GitHub → Settings → Developer settings → Personal access tokens → Tokens (classic)<br>
                            2. "Generate new token (classic)" をクリック<br>
                            3. Note: "FSRS Terms App"<br>
                            4. Expiration: お好みの期間<br>
                            5. Select scopes: "repo" にチェック<br>
                            6. "Generate token" をクリック<br>
                            7. 生成されたトークンをコピーしてここに貼り付け
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="repoOwner">リポジトリオーナー:</label>
                        <input type="text" id="repoOwner" placeholder="your-username">
                    </div>

                    <div class="form-group">
                        <label for="repoName">リポジトリ名:</label>
                        <input type="text" id="repoName" placeholder="fsrs-terms">
                    </div>

                    <div class="form-group">
                        <label for="yamlPath">YAMLファイルパス:</label>
                        <input type="text" id="yamlPath" placeholder="data/terms.yaml" value="data/terms.yaml">
                    </div>

                    <div class="form-group">
                        <label for="mainBranch">ブランチ名:</label>
                        <input type="text" id="mainBranch" placeholder="main" value="main">
                    </div>

                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button id="testConnectionBtn" class="btn btn-secondary">🔌 接続テスト</button>
                        <button id="saveGitHubSettingsBtn" class="btn">💾 設定保存</button>
                        <button id="closeSetupBtn" class="btn btn-danger">❌ 閉じる</button>
                    </div>
                </div>
            </div>

            <!-- アップロード画面 -->
            <div id="uploadScreen" class="upload-area">
                <h2>データの読み込み方法を選択してください</h2>
                <p>YAMLファイルを選択するか、GitHub連携を設定してクラウドから読み込めます</p>
                <div style="margin-top: 20px;">
                    <button class="btn btn-github" onclick="document.getElementById('githubSetupBtn').click()">
                        🔧 GitHub連携を設定
                    </button>
                </div>
                <small style="color: #718096; margin-top: 10px; display: block;">
                    ※ 旧形式のYAMLファイルは自動的にFSRS形式に変換されます
                </small>
            </div>

            <!-- 辞書画面 -->
            <div id="dictionaryScreen" style="display: none;">
                <div class="mode-indicator">📚 辞書モード</div>
                
                <!-- クイック統計 -->
                <div class="quick-stats">
                    <div class="quick-stat">
                        <div class="quick-stat-number" id="totalTerms">0</div>
                        <div class="quick-stat-label">総用語数</div>
                    </div>
                    <div class="quick-stat">
                        <div class="quick-stat-number" id="dueTerms">0</div>
                        <div class="quick-stat-label">復習対象</div>
                    </div>
                    <div class="quick-stat">
                        <div class="quick-stat-number" id="totalReviews">0</div>
                        <div class="quick-stat-label">総復習回数</div>
                    </div>
                    <div class="quick-stat">
                        <div class="quick-stat-number" id="avgDifficulty">0</div>
                        <div class="quick-stat-label">平均難易度</div>
                    </div>
                    <div class="quick-stat">
                        <div class="quick-stat-number" id="masteredTerms">0</div>
                        <div class="quick-stat-label">習得済み</div>
                    </div>
                </div>

                <!-- 学習進捗バー -->
                <div style="margin: 20px 0;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <span style="font-weight: 600; color: #4a5568;">全体の学習進捗</span>
                        <span id="progressPercentage" style="font-size: 0.9rem; color: #667eea;">0%</span>
                    </div>
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                    </div>
                </div>

                <!-- データバックアップ情報 -->
                <div id="backupInfo" class="data-backup-info" style="display: none;">
                    <strong>📡 データ同期情報:</strong><br>
                    最終同期: <span id="lastSyncTime">未同期</span><br>
                    未保存の変更: <span id="unsavedChanges">なし</span>
                </div>

                <div id="termsGrid" class="terms-grid"></div>
            </div>

            <!-- クイズ画面 -->
            <div id="quizScreen" style="display: none;">
                <div class="mode-indicator">🧠 クイズモード - FSRS v6</div>
                <div class="quiz-hint">用語をクリックすると定義が表示されます</div>
                <div class="quiz-container">
                    <div id="quizTerm" class="quiz-term">
                        <div id="termText"></div>
                        <div id="quizDefinition" class="quiz-definition"></div>
                    </div>
                    <div class="quiz-buttons">
                        <button id="againBtn" class="quiz-button btn-danger">❌ Again</button>
                        <button id="hardBtn" class="quiz-button btn-hard">🔶 Hard</button>
                        <button id="goodBtn" class="quiz-button btn-good">✅ Good</button>
                        <button id="easyBtn" class="quiz-button btn-easy">⚡ Easy</button>
                    </div>
                    <div id="debugInfo" class="debug-info" style="display: none;"></div>
                </div>
            </div>

            <!-- 詳細画面 -->
            <div id="detailScreen" style="display: none;">
                <div class="detail-container">
                    <div id="detailTerm" class="detail-term"></div>
                    <div id="detailDescription" class="detail-description"></div>
                    <div id="detailStats" class="stats" style="justify-content: flex-start;">
                        <div class="stat-item">
                            <div class="stat-number" id="detailDifficulty">0</div>
                            <div class="stat-label">難易度</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="detailStability">0</div>
                            <div class="stat-label">安定性(日)</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="detailReviews">0</div>
                            <div class="stat-label">復習回数</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="detailRetrievability">0</div>
                            <div class="stat-label">想起確率</div>
                        </div>
                    </div>
                    <button id="backBtn" class="btn back-button">📚 辞書モードに戻る</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 通知システム -->
    <div id="notification" class="notification"></div>

    <!-- オフライン表示 -->
    <div id="offlineIndicator" class="offline-indicator">
        📡 オフライン - 変更は次回オンライン時に同期されます
    </div>

    <script>
        // FSRS状態の定数
        const State = {
            NEW: 0,
            LEARNING: 1,
            REVIEW: 2,
            RELEARNING: 3
        };

        // FSRS評価の定数
        const Rating = {
            AGAIN: 1,
            HARD: 2,
            GOOD: 3,
            EASY: 4
        };

        /**
         * FSRS (Free Spaced Repetition Scheduler) 実装
         */
        class FSRSCalculator {
            constructor(parameters = {}) {
                this.w = parameters.w || [
                    0.2172, 1.1771, 3.2602, 16.1507, 7.0114, 0.57, 2.0966, 0.0069, 1.5261, 0.112,
                    1.0178, 1.849, 0.1133, 0.3127, 2.2934, 0.2191, 3.0004, 0.7536, 0.3332, 0.1437, 0.2
                ];
                
                this.requestRetention = parameters.requestRetention || 0.9;
                this.maximumInterval = parameters.maximumInterval || 36500;
                this.easyBonus = parameters.easyBonus || 1.3;
                this.hardInterval = parameters.hardInterval || 1.2;
                
                this.FACTOR = 19 / 81;
                this.DECAY = -0.5;
                this.enableDebug = false;
                
                this.intervalCache = new Map();
                this.retrievabilityCache = new Map();
            }

            createEmptyCard(now = new Date()) {
                return {
                    due: now,
                    stability: 0,
                    difficulty: 0,
                    elapsed_days: 0,
                    scheduled_days: 0,
                    reps: 0,
                    lapses: 0,
                    state: State.NEW,
                    last_review: null
                };
            }

            calculateRetrievability(elapsed_days, stability) {
                if (stability <= 0) return 1.0;
                if (elapsed_days < 0) return 1.0;
                
                const cacheKey = `${elapsed_days.toFixed(2)}_${stability.toFixed(2)}`;
                if (this.retrievabilityCache.has(cacheKey)) {
                    return this.retrievabilityCache.get(cacheKey);
                }
                
                const factor = this.FACTOR * elapsed_days / stability;
                const result = Math.pow(1 + factor, this.DECAY);
                
                if (this.retrievabilityCache.size < 1000) {
                    this.retrievabilityCache.set(cacheKey, result);
                }
                
                return result;
            }

            calculateInitialStability(rating) {
                return Math.max(this.w[rating - 1], 0.1);
            }

            calculateInitialDifficulty(rating) {
                const difficulty = this.w[4] - (rating - 3) * this.w[5];
                return Math.max(Math.min(difficulty, 10), 1);
            }

            calculateNextStability(difficulty, stability, retrievability, rating) {
                const hard_penalty = rating === Rating.HARD ? this.w[15] : 1;
                const easy_bonus = rating === Rating.EASY ? this.w[16] : 1;
                
                const factor = Math.exp(this.w[8]) * 
                             (11 - difficulty) * 
                             Math.pow(stability, -this.w[9]) * 
                             (Math.exp(this.w[10] * (1 - retrievability)) - 1) + 1;
                
                return Math.max(stability * factor * hard_penalty * easy_bonus, 0.01);
            }

            calculateForgetStability(difficulty, stability, retrievability) {
                const newStability = this.w[11] * 
                                   Math.pow(difficulty, -this.w[12]) * 
                                   (Math.pow(stability + 1, this.w[13]) - 1) * 
                                   Math.exp(this.w[14] * (1 - retrievability));
                
                return Math.max(Math.min(newStability, stability), 0.01);
            }

            calculateNextDifficulty(difficulty, rating) {
                const delta = rating - 3;
                const nextDifficulty = difficulty - this.w[6] * delta;
                return Math.max(Math.min(nextDifficulty, 10), 1);
            }

            calculateInterval(stability, retention = null) {
                if (retention === null) retention = this.requestRetention;
                if (stability <= 0) return 1;
                
                const cacheKey = `${stability.toFixed(2)}_${retention.toFixed(2)}`;
                if (this.intervalCache.has(cacheKey)) {
                    return this.intervalCache.get(cacheKey);
                }
                
                try {
                    const interval = stability / this.FACTOR * 
                                   (Math.pow(retention, 1 / this.DECAY) - 1);
                    
                    const result = Math.max(interval, 1);
                    
                    if (this.intervalCache.size < 1000) {
                        this.intervalCache.set(cacheKey, result);
                    }
                    
                    return result;
                } catch (error) {
                    console.warn('間隔計算でエラー:', error);
                    return Math.max(stability, 1);
                }
            }

            reviewCard(card, rating, reviewTime = new Date()) {
                try {
                    if (!card || typeof card !== 'object') {
                        throw new Error('無効なカードオブジェクト');
                    }
                    
                    if (!reviewTime || !(reviewTime instanceof Date) || isNaN(reviewTime)) {
                        reviewTime = new Date();
                    }
                    
                    if (typeof card.state !== 'number' || card.state < 0 || card.state > 3) {
                        card.state = State.NEW;
                    }
                    
                    if (typeof card.stability !== 'number' || card.stability < 0) {
                        card.stability = 0;
                    }
                    
                    if (typeof card.difficulty !== 'number' || card.difficulty < 1 || card.difficulty > 10) {
                        card.difficulty = 5;
                    }
                    
                    const now = reviewTime.getTime();
                    const lastReview = card.last_review ? new Date(card.last_review).getTime() : now;
                    const elapsed_days = Math.max((now - lastReview) / (1000 * 60 * 60 * 24), 0);

                    let newCard = { ...card };
                    
                    if (card.state === State.NEW) {
                        newCard.stability = this.calculateInitialStability(rating);
                        newCard.difficulty = this.calculateInitialDifficulty(rating);
                        newCard.elapsed_days = 0;
                        
                        if (rating === Rating.AGAIN) {
                            newCard.state = State.LEARNING;
                            newCard.scheduled_days = 1;
                            newCard.lapses = (card.lapses || 0) + 1;
                        } else {
                            newCard.state = rating === Rating.HARD ? State.LEARNING : State.REVIEW;
                            const interval = this.calculateInterval(newCard.stability);
                            newCard.scheduled_days = Math.min(Math.round(interval), this.maximumInterval);
                            
                            if (rating === Rating.EASY) {
                                newCard.scheduled_days = Math.round(newCard.scheduled_days * this.easyBonus);
                            } else if (rating === Rating.HARD) {
                                newCard.scheduled_days = Math.round(newCard.scheduled_days * this.hardInterval);
                            }
                        }
                    } else {
                        const retrievability = this.calculateRetrievability(elapsed_days, card.stability);
                        newCard.elapsed_days = elapsed_days;
                        
                        if (rating === Rating.AGAIN) {
                            newCard.stability = this.calculateForgetStability(card.difficulty, card.stability, retrievability);
                            newCard.difficulty = this.calculateNextDifficulty(card.difficulty, rating);
                            newCard.state = State.RELEARNING;
                            newCard.scheduled_days = 1;
                            newCard.lapses = (card.lapses || 0) + 1;
                        } else {
                            newCard.stability = this.calculateNextStability(card.difficulty, card.stability, retrievability, rating);
                            newCard.difficulty = this.calculateNextDifficulty(card.difficulty, rating);
                            newCard.state = State.REVIEW;
                            
                            let interval = this.calculateInterval(newCard.stability);
                            
                            if (rating === Rating.EASY) {
                                interval *= this.easyBonus;
                            } else if (rating === Rating.HARD) {
                                interval *= this.hardInterval;
                            }
                            
                            newCard.scheduled_days = Math.min(Math.round(interval), this.maximumInterval);
                        }
                    }
                    
                    newCard.reps = (card.reps || 0) + 1;
                    newCard.lapses = Math.max(newCard.lapses || 0, 0);
                    newCard.stability = Math.max(newCard.stability, 0.01);
                    newCard.difficulty = Math.max(Math.min(newCard.difficulty, 10), 1);
                    newCard.scheduled_days = Math.max(Math.min(newCard.scheduled_days, this.maximumInterval), 1);
                    newCard.last_review = reviewTime.toISOString();
                    newCard.due = new Date(now + newCard.scheduled_days * 24 * 60 * 60 * 1000);

                    if (this.enableDebug) {
                        console.log('FSRS Debug:', {
                            rating,
                            elapsed_days: elapsed_days.toFixed(2),
                            old_stability: card.stability.toFixed(3),
                            new_stability: newCard.stability.toFixed(3),
                            old_difficulty: card.difficulty.toFixed(3),
                            new_difficulty: newCard.difficulty.toFixed(3),
                            interval: newCard.scheduled_days,
                            retrievability: card.state !== State.NEW ? this.calculateRetrievability(elapsed_days, card.stability).toFixed(3) : 1
                        });
                    }

                    return newCard;
                    
                } catch (error) {
                    console.error('FSRS復習処理でエラー:', error);
                    
                    const fallbackCard = { ...card };
                    fallbackCard.reps = (card.reps || 0) + 1;
                    fallbackCard.last_review = reviewTime.toISOString();
                    
                    if (rating === Rating.AGAIN) {
                        fallbackCard.scheduled_days = 1;
                        fallbackCard.lapses = (card.lapses || 0) + 1;
                    } else {
                        fallbackCard.scheduled_days = Math.max(Math.round((card.scheduled_days || 1) * (rating - 1)), 1);
                    }
                    
                    fallbackCard.due = new Date(reviewTime.getTime() + fallbackCard.scheduled_days * 24 * 60 * 60 * 1000);
                    
                    return fallbackCard;
                }
            }

            setDebugMode(enabled) {
                this.enableDebug = enabled;
            }

            clearCache() {
                this.intervalCache.clear();
                this.retrievabilityCache.clear();
            }
        }

        /**
         * GitHub API管理クラス
         */
        class GitHubManager {
            constructor() {
                this.token = null;
                this.owner = null;
                this.repo = null;
                this.yamlPath = null;
                this.branch = 'main';
                this.baseUrl = 'https://api.github.com';
                this.isConnected = false;
                
                this.loadSettings();
            }

            // 設定の保存
            saveSettings() {
                const settings = {
                    token: this.token,
                    owner: this.owner,
                    repo: this.repo,
                    yamlPath: this.yamlPath,
                    branch: this.branch
                };
                
                // 簡単な暗号化（Base64）
                const encoded = btoa(JSON.stringify(settings));
                localStorage.setItem('fsrs_github_settings', encoded);
            }

            // 設定の読み込み
            loadSettings() {
                try {
                    const encoded = localStorage.getItem('fsrs_github_settings');
                    if (encoded) {
                        const settings = JSON.parse(atob(encoded));
                        this.token = settings.token;
                        this.owner = settings.owner;
                        this.repo = settings.repo;
                        this.yamlPath = settings.yamlPath;
                        this.branch = settings.branch || 'main';
                    }
                } catch (error) {
                    console.warn('設定の読み込みに失敗:', error);
                }
            }

            // 接続テスト
            async testConnection() {
                if (!this.token || !this.owner || !this.repo) {
                    throw new Error('必要な設定が不足しています');
                }

                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}`, {
                        headers: {
                            'Authorization': `token ${this.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });

                    if (!response.ok) {
                        if (response.status === 401) {
                            throw new Error('認証に失敗しました。Personal Access Tokenを確認してください。');
                        } else if (response.status === 404) {
                            throw new Error('リポジトリが見つかりません。オーナー名とリポジトリ名を確認してください。');
                        } else {
                            throw new Error(`GitHub API エラー: ${response.status} ${response.statusText}`);
                        }
                    }

                    const repoData = await response.json();
                    this.isConnected = true;
                    return {
                        success: true,
                        message: `✅ 接続成功: ${repoData.full_name}`,
                        repoData
                    };

                } catch (error) {
                    this.isConnected = false;
                    throw error;
                }
            }

            // YAMLファイルの読み込み
            async loadYAML() {
                if (!this.isConnected) {
                    await this.testConnection();
                }

                try {
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/contents/${this.yamlPath}?ref=${this.branch}`, {
                        headers: {
                            'Authorization': `token ${this.token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });

                    if (!response.ok) {
                        if (response.status === 404) {
                            // ファイルが存在しない場合は空のデータを返す
                            return {
                                success: true,
                                data: { terms: [] },
                                message: 'YAMLファイルが見つかりません。新しいファイルを作成します。',
                                isNew: true
                            };
                        } else {
                            throw new Error(`ファイル取得エラー: ${response.status} ${response.statusText}`);
                        }
                    }

                    const fileData = await response.json();
                    
                    // Base64デコード（UTF-8対応）
                    let content;
                    try {
                        // Base64をバイナリに変換
                        const binaryString = atob(fileData.content);
                        
                        // バイナリをUint8Arrayに変換
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        
                        // UTF-8として正しくデコード
                        content = new TextDecoder('utf-8').decode(bytes);
                        
                    } catch (decodeError) {
                        console.warn('UTF-8デコードでエラー、フォールバック処理を実行:', decodeError);
                        // フォールバック: 従来の方法
                        content = decodeURIComponent(escape(atob(fileData.content)));
                    }

                    // 制御文字や不正な文字をクリーンアップ
                    content = this.cleanYAMLContent(content);

                    let data;
                    try {
                        data = jsyaml.load(content);
                    } catch (yamlError) {
                        console.error('YAML解析エラー:', yamlError);
                        console.log('問題のあるコンテンツ:', content.substring(0, 500));
                        throw new Error(`YAML解析エラー: ${yamlError.message}`);
                    }

                    return {
                        success: true,
                        data: data || { terms: [] },
                        message: '✅ GitHubからYAMLファイルを読み込みました',
                        sha: fileData.sha, // 更新に必要
                        isNew: false
                    };

                } catch (error) {
                    throw new Error(`YAML読み込みエラー: ${error.message}`);
                }
            }

            // YAMLコンテンツのクリーンアップ
            cleanYAMLContent(content) {
                // 制御文字（印刷不可能文字）を除去
                content = content.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
                
                // BOMを除去
                content = content.replace(/^\uFEFF/, '');
                
                // 不正なUTF-8シーケンスを置換
                content = content.replace(/\uFFFD/g, '');
                
                // 改行の正規化
                content = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                
                return content;
            }

            // YAMLファイルの保存
            async saveYAML(data, commitMessage = null) {
                if (!this.isConnected) {
                    await this.testConnection();
                }

                try {
                    // まず現在のファイルの情報を取得（SHA値が必要）
                    let currentSha = null;
                    let isUpdate = false;

                    try {
                        const currentResponse = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/contents/${this.yamlPath}?ref=${this.branch}`, {
                            headers: {
                                'Authorization': `token ${this.token}`,
                                'Accept': 'application/vnd.github.v3+json'
                            }
                        });

                        if (currentResponse.ok) {
                            const currentData = await currentResponse.json();
                            currentSha = currentData.sha;
                            isUpdate = true;
                        }
                    } catch (error) {
                        // ファイルが存在しない場合は新規作成
                        console.log('新規ファイルを作成します');
                    }

                    // YAMLデータの準備
                    const yamlData = {
                        version: "FSRS-v6",
                        created: data.created || new Date().toISOString(),
                        updated: new Date().toISOString(),
                        terms: data.terms.map(term => ({
                            ...term,
                            fsrs: {
                                ...term.fsrs,
                                due: typeof term.fsrs.due === 'string' ? term.fsrs.due : term.fsrs.due.toISOString(),
                                last_review: term.fsrs.last_review
                            }
                        }))
                    };

                    let yamlString;
                    try {
                        yamlString = jsyaml.dump(yamlData, {
                            defaultFlowStyle: false,
                            indent: 2,
                            lineWidth: -1,
                            noRefs: true,
                            skipInvalid: true
                        });
                    } catch (yamlError) {
                        throw new Error(`YAML生成エラー: ${yamlError.message}`);
                    }

                    // UTF-8エンコーディングを確実にする
                    let content;
                    try {
                        // UTF-8 Uint8Arrayに変換
                        const encoder = new TextEncoder();
                        const utf8Bytes = encoder.encode(yamlString);
                        
                        // Uint8ArrayをBase64に変換
                        const binaryString = Array.from(utf8Bytes, byte => String.fromCharCode(byte)).join('');
                        content = btoa(binaryString);
                        
                    } catch (encodeError) {
                        console.warn('UTF-8エンコードでエラー、フォールバック処理を実行:', encodeError);
                        // フォールバック: 従来の方法
                        content = btoa(unescape(encodeURIComponent(yamlString)));
                    }

                    // コミットデータの準備
                    const commitData = {
                        message: commitMessage || `${isUpdate ? '更新' : '追加'}: FSRS用語データ (${new Date().toLocaleString('ja-JP')})`,
                        content: content,
                        branch: this.branch
                    };

                    if (currentSha) {
                        commitData.sha = currentSha;
                    }

                    // ファイルをコミット
                    const response = await fetch(`${this.baseUrl}/repos/${this.owner}/${this.repo}/contents/${this.yamlPath}`, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${this.token}`,
                            'Content-Type': 'application/json',
                            'Accept': 'application/vnd.github.v3+json'
                        },
                        body: JSON.stringify(commitData)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`保存エラー: ${response.status} - ${errorData.message || response.statusText}`);
                    }

                    const result = await response.json();
                    return {
                        success: true,
                        message: `✅ GitHubに保存しました: ${result.commit.message}`,
                        commitData: result
                    };

                } catch (error) {
                    throw new Error(`YAML保存エラー: ${error.message}`);
                }
            }

            // 設定のクリア
            clearSettings() {
                localStorage.removeItem('fsrs_github_settings');
                this.token = null;
                this.owner = null;
                this.repo = null;
                this.yamlPath = null;
                this.branch = 'main';
                this.isConnected = false;
            }
        }

        /**
         * メインアプリケーションクラス
         */
        class TermMemorizationApp {
            constructor() {
                this.terms = [];
                this.currentMode = 'upload';
                this.currentQuizTerm = null;
                this.currentDetailTerm = null;
                this.fsrs = new FSRSCalculator();
                this.showingDefinition = false;
                this.github = new GitHubManager();
                this.lastSyncTime = null;
                this.hasUnsavedChanges = false;
                this.isOnline = navigator.onLine;
                
                this.initializeEventListeners();
                this.updateConnectionStatus();
                this.setupOfflineDetection();
                this.loadLocalBackup();
            }

            // 通知システム
            showNotification(message, type = 'info', duration = 3000) {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.className = `notification ${type}`;
                notification.classList.add('show');

                setTimeout(() => {
                    notification.classList.remove('show');
                }, duration);
            }

            // オフライン検出
            setupOfflineDetection() {
                const offlineIndicator = document.getElementById('offlineIndicator');
                
                window.addEventListener('online', () => {
                    this.isOnline = true;
                    offlineIndicator.style.display = 'none';
                    this.showNotification('オンラインに復帰しました', 'success');
                    this.updateConnectionStatus();
                });

                window.addEventListener('offline', () => {
                    this.isOnline = false;
                    offlineIndicator.style.display = 'block';
                    this.showNotification('オフラインモードです', 'info');
                    this.updateConnectionStatus();
                });

                // 初期状態の設定
                if (!this.isOnline) {
                    offlineIndicator.style.display = 'block';
                }
            }

            // ローカルバックアップの読み込み
            loadLocalBackup() {
                try {
                    const backup = localStorage.getItem('fsrs_local_backup');
                    if (backup) {
                        const data = JSON.parse(backup);
                        if (data.terms && Array.isArray(data.terms) && data.terms.length > 0) {
                            const backupDate = new Date(data.timestamp).toLocaleString('ja-JP');
                            console.log(`ローカルバックアップを検出: ${backupDate}`);
                            // 必要に応じて復元の提案をユーザーに表示
                        }
                    }
                } catch (error) {
                    console.warn('ローカルバックアップの読み込みエラー:', error);
                }
            }

            // ローカルバックアップの保存
            saveLocalBackup() {
                try {
                    const backup = {
                        terms: this.terms,
                        timestamp: new Date().toISOString(),
                        version: "FSRS-v6"
                    };
                    localStorage.setItem('fsrs_local_backup', JSON.stringify(backup));
                    console.log('ローカルバックアップを保存しました');
                } catch (error) {
                    console.warn('ローカルバックアップの保存エラー:', error);
                }
            }

            // データ整合性チェック
            validateTermsData(terms) {
                const errors = [];
                
                if (!Array.isArray(terms)) {
                    errors.push('用語データが配列ではありません');
                    return errors;
                }

                terms.forEach((term, index) => {
                    if (!term.term || typeof term.term !== 'string') {
                        errors.push(`用語${index + 1}: 用語名が無効です`);
                    }
                    
                    if (!term.description || typeof term.description !== 'string') {
                        errors.push(`用語${index + 1}: 説明が無効です`);
                    }
                    
                    if (!term.fsrs || typeof term.fsrs !== 'object') {
                        errors.push(`用語${index + 1}: FSRSデータが無効です`);
                    } else {
                        const fsrs = term.fsrs;
                        if (typeof fsrs.stability !== 'number' || fsrs.stability < 0) {
                            errors.push(`用語${index + 1}: 安定性の値が無効です`);
                        }
                        if (typeof fsrs.difficulty !== 'number' || fsrs.difficulty < 1 || fsrs.difficulty > 10) {
                            errors.push(`用語${index + 1}: 難易度の値が無効です`);
                        }
                    }
                });

                return errors;
            }

            initializeEventListeners() {
                // ファイルアップロード
                document.getElementById('yamlFile').addEventListener('change', (e) => {
                    this.handleFileUpload(e);
                });

                // GitHub設定
                document.getElementById('githubSetupBtn').addEventListener('click', () => {
                    this.showGitHubSetup();
                });

                document.getElementById('testConnectionBtn').addEventListener('click', () => {
                    this.testGitHubConnection();
                });

                document.getElementById('saveGitHubSettingsBtn').addEventListener('click', () => {
                    this.saveGitHubSettings();
                });

                document.getElementById('closeSetupBtn').addEventListener('click', () => {
                    this.closeGitHubSetup();
                });

                // GitHub操作
                document.getElementById('loadFromGitHubBtn').addEventListener('click', () => {
                    this.loadFromGitHub();
                });

                document.getElementById('saveToGitHubBtn').addEventListener('click', () => {
                    this.saveToGitHub();
                });

                // YAML修復機能
                document.getElementById('repairYamlBtn')?.addEventListener('click', () => {
                    this.repairYamlFile();
                });

                // デバッグ機能
                document.getElementById('debugBtn')?.addEventListener('click', () => {
                    this.showDebugInfo();
                });

                // モード切り替え
                document.getElementById('dictionaryMode').addEventListener('click', () => {
                    this.switchMode('dictionary');
                });

                document.getElementById('quizMode').addEventListener('click', () => {
                    this.switchMode('quiz');
                });

                // クイズ操作
                document.getElementById('againBtn').addEventListener('click', () => {
                    this.handleQuizAnswer(Rating.AGAIN);
                });

                document.getElementById('hardBtn').addEventListener('click', () => {
                    this.handleQuizAnswer(Rating.HARD);
                });

                document.getElementById('goodBtn').addEventListener('click', () => {
                    this.handleQuizAnswer(Rating.GOOD);
                });

                document.getElementById('easyBtn').addEventListener('click', () => {
                    this.handleQuizAnswer(Rating.EASY);
                });

                // 用語クリックで定義表示
                document.getElementById('quizTerm').addEventListener('click', () => {
                    this.toggleDefinition();
                });

                // 詳細画面から戻る
                document.getElementById('backBtn').addEventListener('click', () => {
                    this.switchMode('dictionary');
                });

                // ダウンロード
                document.getElementById('downloadBtn').addEventListener('click', () => {
                    this.downloadUpdatedYAML();
                });

                // ヘルプ
                document.getElementById('helpBtn').addEventListener('click', () => {
                    this.showHelp();
                });

                // デバッグ用キーボードショートカット
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'D' && e.shiftKey) {
                        const debugDiv = document.getElementById('debugInfo');
                        debugDiv.style.display = debugDiv.style.display === 'none' ? 'block' : 'none';
                        this.fsrs.setDebugMode(debugDiv.style.display === 'block');
                    } else if (e.key === 'P' && e.shiftKey) {
                        this.showPerformanceStats();
                    } else if (e.key === 'C' && e.shiftKey) {
                        this.fsrs.clearCache();
                        alert('キャッシュをクリアしました');
                    }
                });
            }

            updateConnectionStatus() {
                const statusDiv = document.getElementById('connectionStatus');
                const loadBtn = document.getElementById('loadFromGitHubBtn');
                const saveBtn = document.getElementById('saveToGitHubBtn');

                if (this.github.isConnected) {
                    statusDiv.className = 'connection-status status-connected';
                    statusDiv.innerHTML = `✅ GitHub接続済み: ${this.github.owner}/${this.github.repo}`;
                    loadBtn.disabled = false;
                    saveBtn.disabled = this.terms.length === 0;
                } else if (this.github.token && this.github.owner && this.github.repo) {
                    statusDiv.className = 'connection-status status-disconnected';
                    statusDiv.innerHTML = '⚠️ GitHub設定済み（未接続）';
                    loadBtn.disabled = false;
                    saveBtn.disabled = true;
                } else {
                    statusDiv.className = 'connection-status status-disconnected';
                    statusDiv.innerHTML = '❌ GitHub未設定';
                    loadBtn.disabled = true;
                    saveBtn.disabled = true;
                }
            }

            showGitHubSetup() {
                // 現在の設定値をフォームにセット
                document.getElementById('githubToken').value = this.github.token || '';
                document.getElementById('repoOwner').value = this.github.owner || '';
                document.getElementById('repoName').value = this.github.repo || '';
                document.getElementById('yamlPath').value = this.github.yamlPath || 'data/terms.yaml';
                document.getElementById('mainBranch').value = this.github.branch || 'main';

                this.switchMode('github-setup');
            }

            async testGitHubConnection() {
                const testBtn = document.getElementById('testConnectionBtn');
                const originalText = testBtn.textContent;
                
                try {
                    testBtn.disabled = true;
                    testBtn.innerHTML = '<span class="loading-spinner"></span> 接続中...';
                    
                    // フォームの値を一時的に設定
                    this.github.token = document.getElementById('githubToken').value.trim();
                    this.github.owner = document.getElementById('repoOwner').value.trim();
                    this.github.repo = document.getElementById('repoName').value.trim();
                    this.github.yamlPath = document.getElementById('yamlPath').value.trim();
                    this.github.branch = document.getElementById('mainBranch').value.trim() || 'main';

                    const result = await this.github.testConnection();
                    
                    this.showNotification(result.message, 'success');
                    this.updateConnectionStatus();
                    
                } catch (error) {
                    console.error('接続テストエラー:', error);
                    this.showNotification(`接続エラー: ${error.message}`, 'error');
                    this.github.isConnected = false;
                    this.updateConnectionStatus();
                } finally {
                    testBtn.disabled = false;
                    testBtn.textContent = originalText;
                }
            }

            saveGitHubSettings() {
                // フォームの値を保存
                this.github.token = document.getElementById('githubToken').value.trim();
                this.github.owner = document.getElementById('repoOwner').value.trim();
                this.github.repo = document.getElementById('repoName').value.trim();
                this.github.yamlPath = document.getElementById('yamlPath').value.trim();
                this.github.branch = document.getElementById('mainBranch').value.trim() || 'main';

                if (!this.github.token || !this.github.owner || !this.github.repo || !this.github.yamlPath) {
                    this.showNotification('すべての必須項目を入力してください', 'error');
                    return;
                }

                this.github.saveSettings();
                this.showNotification('GitHub設定を保存しました', 'success');
                this.updateConnectionStatus();
                this.closeGitHubSetup();
            }

            closeGitHubSetup() {
                this.switchMode('upload');
            }

            async loadFromGitHub() {
                const loadBtn = document.getElementById('loadFromGitHubBtn');
                const originalText = loadBtn.textContent;
                
                if (!this.isOnline) {
                    this.showNotification('オフラインのため読み込みできません', 'error');
                    return;
                }
                
                try {
                    loadBtn.disabled = true;
                    loadBtn.innerHTML = '<span class="loading-spinner"></span> 読み込み中...';
                    
                    const result = await this.github.loadYAML();
                    
                    if (result.data && result.data.terms && Array.isArray(result.data.terms)) {
                        // データ整合性チェック
                        const validationErrors = this.validateTermsData(result.data.terms);
                        if (validationErrors.length > 0) {
                            console.warn('データ整合性の警告:', validationErrors);
                            this.showNotification(`データに${validationErrors.length}個の警告があります`, 'warning');
                        }
                        
                        let conversionCount = 0;
                        
                        this.terms = result.data.terms.map(term => {
                            if (!term.fsrs || typeof term.fsrs !== 'object') {
                                conversionCount++;
                                const fsrsCard = this.fsrs.createEmptyCard();
                                return {
                                    term: term.term || '',
                                    description: term.description || '',
                                    miss_count: term.miss_count || 0,
                                    fsrs: fsrsCard
                                };
                            } else {
                                const fsrsData = { ...term.fsrs };
                                
                                try {
                                    fsrsData.due = term.fsrs.due ? new Date(term.fsrs.due) : new Date();
                                    if (isNaN(fsrsData.due)) {
                                        fsrsData.due = new Date();
                                    }
                                } catch (e) {
                                    fsrsData.due = new Date();
                                }
                                
                                fsrsData.stability = Math.max(fsrsData.stability || 0, 0);
                                fsrsData.difficulty = Math.max(Math.min(fsrsData.difficulty || 5, 10), 1);
                                fsrsData.reps = Math.max(fsrsData.reps || 0, 0);
                                fsrsData.lapses = Math.max(fsrsData.lapses || 0, 0);
                                fsrsData.state = [0, 1, 2, 3].includes(fsrsData.state) ? fsrsData.state : 0;
                                
                                return {
                                    term: term.term || '',
                                    description: term.description || '',
                                    miss_count: term.miss_count || 0,
                                    fsrs: fsrsData
                                };
                            }
                        });
                        
                        this.enableControls();
                        this.switchMode('dictionary');
                        this.lastSyncTime = new Date().toISOString();
                        this.hasUnsavedChanges = false;
                        this.saveLocalBackup();
                        
                        let message = `${this.terms.length}個の用語を読み込みました`;
                        if (conversionCount > 0) {
                            message += ` (${conversionCount}個を新形式に変換)`;
                        }
                        if (result.isNew) {
                            message += '\n初回使用時は保存ボタンでファイルを作成してください';
                        }
                        
                        this.showNotification(message, 'success');
                        
                    } else {
                        throw new Error('無効なYAMLファイル形式です。terms配列が必要です。');
                    }
                    
                } catch (error) {
                    console.error('GitHub読み込みエラー:', error);
                    this.showNotification(`読み込みエラー: ${error.message}`, 'error');
                    
                    // オフライン時はローカルバックアップを提案
                    if (!this.isOnline) {
                        const backup = localStorage.getItem('fsrs_local_backup');
                        if (backup && confirm('ローカルバックアップを使用しますか？')) {
                            this.loadFromLocalBackup();
                        }
                    }
                } finally {
                    loadBtn.disabled = false;
                    loadBtn.textContent = originalText;
                    this.updateConnectionStatus();
                }
            }

            async saveToGitHub() {
                const saveBtn = document.getElementById('saveToGitHubBtn');
                const originalText = saveBtn.textContent;
                
                if (!this.isOnline) {
                    this.showNotification('オフラインのため保存できません', 'error');
                    this.saveLocalBackup(); // ローカルバックアップは保存
                    return;
                }
                
                try {
                    saveBtn.disabled = true;
                    saveBtn.innerHTML = '<span class="loading-spinner"></span> 保存中...';
                    
                    const yamlData = {
                        version: "FSRS-v6",
                        created: new Date().toISOString(),
                        terms: this.terms
                    };

                    const result = await this.github.saveYAML(yamlData);
                    
                    this.lastSyncTime = new Date().toISOString();
                    this.hasUnsavedChanges = false;
                    this.saveLocalBackup();
                    this.updateBackupInfo();
                    
                    this.showNotification('GitHubに保存しました', 'success');
                    
                } catch (error) {
                    console.error('GitHub保存エラー:', error);
                    this.showNotification(`保存エラー: ${error.message}`, 'error');
                    
                    // エラー時もローカルバックアップは保存
                    this.saveLocalBackup();
                } finally {
                    saveBtn.disabled = false;
                    saveBtn.textContent = originalText;
                }
            }

            loadFromLocalBackup() {
                try {
                    const backup = localStorage.getItem('fsrs_local_backup');
                    if (backup) {
                        const data = JSON.parse(backup);
                        this.terms = data.terms;
                        this.enableControls();
                        this.switchMode('dictionary');
                        this.showNotification('ローカルバックアップから復元しました', 'info');
                    }
                } catch (error) {
                    this.showNotification('ローカルバックアップの読み込みに失敗しました', 'error');
                }
            }

            async handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    this.showNotification('ファイルを読み込み中...', 'info');
                    
                    const text = await file.text();
                    const data = jsyaml.load(text);
                    
                    if (data && data.terms && Array.isArray(data.terms)) {
                        // データ整合性チェック
                        const validationErrors = this.validateTermsData(data.terms);
                        if (validationErrors.length > 0) {
                            console.warn('データ整合性の警告:', validationErrors);
                            this.showNotification(`データに${validationErrors.length}個の警告があります`, 'warning');
                        }
                        
                        let conversionCount = 0;
                        
                        this.terms = data.terms.map(term => {
                            if (!term.fsrs || typeof term.fsrs !== 'object') {
                                conversionCount++;
                                const fsrsCard = this.fsrs.createEmptyCard();
                                return {
                                    term: term.term || '',
                                    description: term.description || '',
                                    miss_count: term.miss_count || 0,
                                    fsrs: fsrsCard
                                };
                            } else {
                                const fsrsData = { ...term.fsrs };
                                
                                try {
                                    fsrsData.due = term.fsrs.due ? new Date(term.fsrs.due) : new Date();
                                    if (isNaN(fsrsData.due)) {
                                        fsrsData.due = new Date();
                                    }
                                } catch (e) {
                                    fsrsData.due = new Date();
                                }
                                
                                fsrsData.stability = Math.max(fsrsData.stability || 0, 0);
                                fsrsData.difficulty = Math.max(Math.min(fsrsData.difficulty || 5, 10), 1);
                                fsrsData.reps = Math.max(fsrsData.reps || 0, 0);
                                fsrsData.lapses = Math.max(fsrsData.lapses || 0, 0);
                                fsrsData.state = [0, 1, 2, 3].includes(fsrsData.state) ? fsrsData.state : 0;
                                
                                return {
                                    term: term.term || '',
                                    description: term.description || '',
                                    miss_count: term.miss_count || 0,
                                    fsrs: fsrsData
                                };
                            }
                        });
                        
                        this.enableControls();
                        this.switchMode('dictionary');
                        this.hasUnsavedChanges = true;
                        this.saveLocalBackup();
                        
                        let message = `${this.terms.length}個の用語を読み込みました`;
                        if (conversionCount > 0) {
                            message += ` (${conversionCount}個を新形式に変換)`;
                        }
                        
                        this.showNotification(message, 'success');
                        
                    } else {
                        throw new Error('無効なYAMLファイル形式です。terms配列が必要です。');
                    }
                } catch (error) {
                    console.error('ファイル読み込みエラー:', error);
                    this.showNotification(`ファイル読み込みエラー: ${error.message}`, 'error');
                }
            }

            enableControls() {
                document.getElementById('dictionaryMode').disabled = false;
                document.getElementById('quizMode').disabled = false;
                document.getElementById('downloadBtn').disabled = false;
                this.updateConnectionStatus();
            }

            switchMode(mode) {
                // 全ての画面を非表示
                document.getElementById('uploadScreen').style.display = 'none';
                document.getElementById('githubSetupScreen').style.display = 'none';
                document.getElementById('dictionaryScreen').style.display = 'none';
                document.getElementById('quizScreen').style.display = 'none';
                document.getElementById('detailScreen').style.display = 'none';

                this.currentMode = mode;

                switch (mode) {
                    case 'github-setup':
                        document.getElementById('githubSetupScreen').style.display = 'block';
                        break;
                    case 'dictionary':
                        this.showDictionaryMode();
                        break;
                    case 'quiz':
                        this.showQuizMode();
                        break;
                    case 'detail':
                        this.showDetailMode();
                        break;
                    default:
                        document.getElementById('uploadScreen').style.display = 'block';
                        break;
                }
            }

            showDictionaryMode() {
                document.getElementById('dictionaryScreen').style.display = 'block';
                this.updateStats();
                this.renderTermsGrid();
            }

            updateStats() {
                const totalTerms = this.terms.length;
                const now = new Date();
                const dueTerms = this.terms.filter(term => {
                    return new Date(term.fsrs.due) <= now;
                }).length;
                const totalReviews = this.terms.reduce((sum, term) => sum + term.fsrs.reps, 0);
                
                // 新しい統計計算
                const avgDifficulty = totalTerms > 0 ? 
                    this.terms.reduce((sum, term) => sum + (term.fsrs.difficulty || 5), 0) / totalTerms : 0;
                
                // 習得済み用語（安定性が30日以上かつ復習回数が3回以上）
                const masteredTerms = this.terms.filter(term => 
                    term.fsrs.stability >= 30 && term.fsrs.reps >= 3
                ).length;
                
                // 進捗計算（全用語のうち少なくとも1回復習済みの割合）
                const reviewedTerms = this.terms.filter(term => term.fsrs.reps > 0).length;
                const progressPercentage = totalTerms > 0 ? Math.round((reviewedTerms / totalTerms) * 100) : 0;
                
                // DOM更新
                document.getElementById('totalTerms').textContent = totalTerms;
                document.getElementById('dueTerms').textContent = dueTerms;
                document.getElementById('totalReviews').textContent = totalReviews;
                document.getElementById('avgDifficulty').textContent = avgDifficulty.toFixed(1);
                document.getElementById('masteredTerms').textContent = masteredTerms;
                document.getElementById('progressPercentage').textContent = `${progressPercentage}%`;
                document.getElementById('progressFill').style.width = `${progressPercentage}%`;
                
                // バックアップ情報の更新
                this.updateBackupInfo();
            }

            updateBackupInfo() {
                const backupInfo = document.getElementById('backupInfo');
                const lastSyncTimeElement = document.getElementById('lastSyncTime');
                const unsavedChangesElement = document.getElementById('unsavedChanges');
                
                if (this.github.isConnected) {
                    backupInfo.style.display = 'block';
                    
                    if (this.lastSyncTime) {
                        lastSyncTimeElement.textContent = new Date(this.lastSyncTime).toLocaleString('ja-JP');
                    } else {
                        lastSyncTimeElement.textContent = '未同期';
                    }
                    
                    unsavedChangesElement.textContent = this.hasUnsavedChanges ? 'あり' : 'なし';
                    unsavedChangesElement.style.color = this.hasUnsavedChanges ? '#e53e3e' : '#48bb78';
                } else {
                    backupInfo.style.display = 'none';
                }
            }

            renderTermsGrid() {
                const grid = document.getElementById('termsGrid');
                grid.innerHTML = '';

                this.terms.forEach((term, index) => {
                    const card = document.createElement('div');
                    card.className = 'term-card';
                    
                    const nextReviewText = this.formatNextReview(new Date(term.fsrs.due));
                    
                    card.innerHTML = `
                        <div class="term-name">${this.escapeHtml(term.term)}</div>
                        <div class="term-stats">
                            <div class="stat-badge miss-count">復習: ${term.fsrs.reps}回</div>
                            <div class="stat-badge difficulty">難易度: ${term.fsrs.difficulty.toFixed(1)}</div>
                            <div class="stat-badge next-review">次回: ${nextReviewText}</div>
                        </div>
                    `;
                    
                    card.addEventListener('click', () => {
                        this.showTermDetail(index);
                    });
                    
                    grid.appendChild(card);
                });
            }

            formatNextReview(nextReview) {
                const now = new Date();
                const diffTime = nextReview - now;
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                
                if (diffDays <= 0) return '復習予定';
                if (diffDays === 1) return '1日後';
                if (diffDays < 30) return `${diffDays}日後`;
                if (diffDays < 365) return `${Math.floor(diffDays / 30)}ヶ月後`;
                return `${Math.floor(diffDays / 365)}年後`;
            }

            showTermDetail(termIndex) {
                this.currentDetailTerm = termIndex;
                const term = this.terms[termIndex];
                
                const retrievability = term.fsrs.state !== State.NEW && term.fsrs.last_review
                    ? this.fsrs.calculateRetrievability(
                        (Date.now() - new Date(term.fsrs.last_review).getTime()) / (1000 * 60 * 60 * 24),
                        term.fsrs.stability
                    )
                    : 1;
                
                document.getElementById('detailTerm').textContent = term.term;
                document.getElementById('detailDescription').textContent = term.description;
                document.getElementById('detailDifficulty').textContent = term.fsrs.difficulty.toFixed(1);
                document.getElementById('detailStability').textContent = Math.round(term.fsrs.stability);
                document.getElementById('detailReviews').textContent = term.fsrs.reps;
                document.getElementById('detailRetrievability').textContent = (retrievability * 100).toFixed(1) + '%';
                
                this.switchMode('detail');
            }

            showDetailMode() {
                document.getElementById('detailScreen').style.display = 'block';
            }

            showQuizMode() {
                document.getElementById('quizScreen').style.display = 'block';
                this.showNextDueTerm();
            }

            showNextDueTerm() {
                if (this.terms.length === 0) return;
                
                const now = new Date();
                const dueTerms = this.terms
                    .map((term, index) => ({ term, index }))
                    .filter(({ term }) => new Date(term.fsrs.due) <= now)
                    .sort((a, b) => {
                        return new Date(a.term.fsrs.due) - new Date(b.term.fsrs.due);
                    });

                if (dueTerms.length === 0) {
                    this.currentQuizTerm = Math.floor(Math.random() * this.terms.length);
                } else {
                    this.currentQuizTerm = dueTerms[0].index;
                }

                this.showingDefinition = false;
                this.updateQuizDisplay();
            }

            updateQuizDisplay() {
                const term = this.terms[this.currentQuizTerm];
                document.getElementById('termText').textContent = term.term;
                document.getElementById('quizDefinition').textContent = term.description;
                
                const quizTerm = document.getElementById('quizTerm');
                const quizDefinition = document.getElementById('quizDefinition');
                
                if (this.showingDefinition) {
                    quizTerm.classList.add('show-definition');
                    quizDefinition.classList.add('visible');
                } else {
                    quizTerm.classList.remove('show-definition');
                    quizDefinition.classList.remove('visible');
                }

                if (this.fsrs.enableDebug) {
                    this.updateDebugInfo(term);
                }
            }

            updateDebugInfo(term) {
                const elapsed = term.fsrs.last_review 
                    ? (Date.now() - new Date(term.fsrs.last_review).getTime()) / (1000 * 60 * 60 * 24)
                    : 0;
                const retrievability = term.fsrs.state !== State.NEW && term.fsrs.last_review
                    ? this.fsrs.calculateRetrievability(elapsed, term.fsrs.stability)
                    : 1;

                const debugInfo = `
                    状態: ${Object.keys(State)[term.fsrs.state]} | 
                    難易度: ${term.fsrs.difficulty.toFixed(2)} | 
                    安定性: ${term.fsrs.stability.toFixed(2)}日 | 
                    経過: ${elapsed.toFixed(1)}日 | 
                    想起確率: ${(retrievability * 100).toFixed(1)}% | 
                    復習回数: ${term.fsrs.reps}
                `;
                document.getElementById('debugInfo').textContent = debugInfo;
            }

            toggleDefinition() {
                this.showingDefinition = !this.showingDefinition;
                this.updateQuizDisplay();
            }

            handleQuizAnswer(rating) {
                if (this.currentQuizTerm === null) return;

                const term = this.terms[this.currentQuizTerm];
                const updatedFsrs = this.fsrs.reviewCard(term.fsrs, rating);
                this.terms[this.currentQuizTerm].fsrs = updatedFsrs;

                // 変更フラグを設定
                this.hasUnsavedChanges = true;
                this.saveLocalBackup();
                this.updateBackupInfo();

                // 10回答ごとに保存を提案
                const totalAnswers = this.terms.reduce((sum, term) => sum + term.fsrs.reps, 0);
                if (this.github.isConnected && this.isOnline && totalAnswers % 10 === 0 && this.hasUnsavedChanges) {
                    if (confirm('10回答が完了しました。GitHubに保存しますか？')) {
                        this.saveToGitHub();
                    }
                }

                this.showNextDueTerm();
            }

            downloadUpdatedYAML() {
                try {
                    const yamlData = {
                        version: "FSRS-v6",
                        created: new Date().toISOString(),
                        terms: this.terms.map(term => ({
                            ...term,
                            fsrs: {
                                ...term.fsrs,
                                due: term.fsrs.due.toISOString(),
                                last_review: term.fsrs.last_review
                            }
                        }))
                    };

                    const yamlString = jsyaml.dump(yamlData, {
                        defaultFlowStyle: false,
                        indent: 2
                    });

                    const blob = new Blob([yamlString], { type: 'text/yaml' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `fsrs_terms_${new Date().toISOString().split('T')[0]}.yaml`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    URL.revokeObjectURL(url);
                    
                    alert('YAMLファイルをダウンロードしました');
                } catch (error) {
                    console.error('ダウンロードエラー:', error);
                    alert('ダウンロードに失敗しました: ' + error.message);
                }
            }

            showPerformanceStats() {
                const totalTerms = this.terms.length;
                const totalReviews = this.terms.reduce((sum, term) => sum + (term.fsrs.reps || 0), 0);
                const avgDifficulty = totalTerms > 0 ? 
                    this.terms.reduce((sum, term) => sum + (term.fsrs.difficulty || 5), 0) / totalTerms : 0;
                const avgStability = totalTerms > 0 ? 
                    this.terms.reduce((sum, term) => sum + (term.fsrs.stability || 0), 0) / totalTerms : 0;
                
                const message = `
=== FSRS パフォーマンス統計 ===

用語データ:
- 総用語数: ${totalTerms}
- 総復習回数: ${totalReviews}
- 平均難易度: ${avgDifficulty.toFixed(2)}
- 平均安定性: ${avgStability.toFixed(2)}日

GitHub連携:
- 接続状態: ${this.github.isConnected ? '接続済み' : '未接続'}
- リポジトリ: ${this.github.owner}/${this.github.repo}
- YAMLパス: ${this.github.yamlPath}

メモリ使用量: ${(JSON.stringify(this.terms).length / 1024).toFixed(1)} KB

キーボードショートカット:
- Shift+D: デバッグモード切り替え
- Shift+P: パフォーマンス統計表示
- Shift+C: キャッシュクリア
                `;
                
                alert(message);
            }

            showHelp() {
                const helpContent = `
=== FSRS用語暗記アプリ - GitHub連携版 v2.0 ヘルプ ===

🎯 概要:
最新のFSRS-6アルゴリズムとGitHub連携機能を搭載した
科学的根拠に基づく用語暗記アプリです。

🌟 新機能 (v2.0):
- ✅ リアルタイム通知システム
- ✅ オフライン対応とローカルバックアップ
- ✅ 詳細学習統計とプログレス表示
- ✅ データ整合性チェック
- ✅ 自動保存提案システム
- ✅ レスポンシブ UI改善

🔧 GitHub連携設定:
1. Personal Access Token作成
   - GitHub → Settings → Developer settings
   - "repo" スコープで新しいトークンを生成
2. アプリでGitHub設定
   - トークン、オーナー、リポジトリ名を入力
   - 接続テストで確認

📁 推奨リポジトリ構成:
your-repo/
├── index.html          # このアプリ
├── data/
│   └── terms.yaml     # 用語データ
└── README.md

🧠 学習システム:
- 🔴 Again: 完全に忘れた（間隔リセット）
- 🟠 Hard: 困難だった（間隔短縮）
- 🟢 Good: 標準的（通常間隔）
- 🔵 Easy: 簡単（間隔延長）

📊 学習統計:
- 総用語数: 登録された全用語
- 復習対象: 今日復習すべき用語
- 習得済み: 安定性30日以上の用語
- 進捗率: 一度でも復習した用語の割合

🔄 データ同期:
- 自動: 10回答ごとに保存提案
- 手動: 「GitHubに保存」ボタン
- バックアップ: ローカルストレージに自動保存
- オフライン: ローカルバックアップで継続学習

🔒 セキュリティ:
- Personal Access Token暗号化保存
- プライベートリポジトリ推奨
- トークン定期更新推奨

⌨️ ショートカット:
- Shift+D: デバッグモード切り替え
- Shift+P: パフォーマンス統計表示
- Shift+C: FSRSキャッシュクリア

🌐 オフライン機能:
- ローカルバックアップ自動保存
- オフライン学習継続可能
- オンライン復帰時に同期提案

🚨 トラブルシューティング:
1. 接続エラー → トークン・リポジトリ情報確認
2. 保存エラー → 権限・ネットワーク確認
3. データエラー → YAML形式・整合性確認

📱 マルチデバイス対応:
- レスポンシブデザイン
- クラウド同期でデバイス間共有
- 学習進捗の一元管理

💡 効率的な学習のコツ:
- 毎日の復習習慣
- 正直な自己評価
- 定期的なデータバックアップ
- 統計データの活用

🔄 更新情報 (v2.0):
- 大幅なUX改善
- エラーハンドリング強化
- パフォーマンス最適化
- セキュリティ向上

© 2025 FSRS Community - Enhanced GitHub Edition
科学的学習で知識を確実に定着させましょう！
                `;
                
                this.showNotification('ヘルプを表示中', 'info', 1000);
                setTimeout(() => {
                    alert(helpContent);
                }, 1000);
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // アプリケーション初期化
        document.addEventListener('DOMContentLoaded', () => {
            new TermMemorizationApp();
        });
    </script>
</body>
</html>